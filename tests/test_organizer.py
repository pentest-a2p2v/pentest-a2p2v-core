#!/usr/bin/env python3
#
#  Copyright (C) 2018-2021 Toshiba Corporation and Peraton Labs, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.


"""Pyunit test cases for a2p2v organizer
The organizer:
- support "single host" and "system" modes
- uses the Simulator to call Metasploit API commands
- maintains track of metasploit state
- collects the results for a report

The test cases check this functionality leveraging
the python unittest mock library to patch modules
so that the Metasploit API calls are not actually made.
"""
import datetime
from unittest import mock

from a2p2v.organizer import Organizer

from .sampledata import sample_config


# Patch the Simulator so it does not call metasploit APIs
# Patch time.sleep so it does not sleep
@mock.patch("a2p2v.organizer.Simulator")
@mock.patch("time.sleep")
@mock.patch("builtins.open")
def test_organizer_init(mock_file, mock_sleep, mock_executor):
    """Test the organizer constructor
    Arguments:
        mock_sleep: patched so it will not sleep
        mock_executor: patched to not call metasploit
    """
    # time.sleep is patched so it does not sleep
    mock_sleep.return_value = None
    mock_file.return_value = mock.MagicMock()

    # Simulator is patched
    instance = mock_executor.return_value
    instance.valid = True

    # The read() method always returns static data
    instance.read.return_value = {
        "prompt": "msf5> ",
        "busy": False,
        "data": "",
    }

    # Mock the planner
    planner = mock.MagicMock()
    attack_tree_list = {"attack_tree_list": "testing"}
    planner.attack_trees = attack_tree_list

    # Create an organizer
    organizer = Organizer(
        planner, mode="system", minimum_score=0.0, execute=True
    )

    assert organizer.attack_trees['attack_tree_list'] == "testing"


@mock.patch.object(Organizer, '_set_metasploit_globals')
@mock.patch.object(Organizer, '_skip_banner')
@mock.patch.object(Organizer, '__init__', return_value=None)
@mock.patch("a2p2v.organizer.Simulator")
def test_init_executor(
    mock_executor,
    mock_organizer_init,
    mock_skip_banner,
    mock_set_metasploit_globals,
):
    """Test the Organizer.init_executor() function
    Arguments:
        mock_executor: patched to not call metasploit
        mock_organizer_init: patched to not perform constructor
        mock_skip_banner: patched to not call metasploit
        mock_set_metasploit_globals: patched to not call metasploit
    """
    # Create an Organizer: skip_banner and set_metasploit_globals are patched
    organizer = Organizer(planner=None, mode="system", minimum_score=0.0)
    # Assert the mocked Organizer.__init__ () was called.
    mock_organizer_init.assert_called()

    # Mock the executor
    organizer._executor = mock_executor
    organizer.execute_enabled = True

    # Test1: Invalid executor
    mock_executor.valid = False
    organizer._init_executor()

    # Check that methods were not called
    mock_skip_banner.assert_not_called()
    mock_set_metasploit_globals.assert_not_called()

    # Test2: Valid executor
    mock_executor.valid = True
    organizer._init_executor()

    # Check that methods were called
    mock_skip_banner.assert_called()
    mock_set_metasploit_globals.assert_called()


@mock.patch.object(Organizer, '__init__', return_value=None)
def test_skip_banner(mock_organizer_init):
    """Test the Organizer.skip_banner() function
    Arguments:
        mock_organizer_init: patched to not perform constructor
    """
    # Create an Organizer: skip_banner and set_metasploit_globals are patched
    organizer = Organizer(planner=None, mode="system", minimum_score=0.0)

    # Assert the mocked Organizer.__init__ () was called.
    mock_organizer_init.assert_called()

    # Mock the executor
    mock_executor = mock.MagicMock()
    organizer._executor = mock_executor

    # The read() method always returns static data
    mock_executor.read.return_value = {
        "prompt": "msf5> ",
        "busy": False,
        "data": "",
    }

    # Call skip banner
    organizer._skip_banner()

    # Ensure that the executor read was called
    mock_executor.read.assert_called()


@mock.patch.object(Organizer, '_log_line')
@mock.patch.object(Organizer, '_send_command')
@mock.patch.object(Organizer, '__init__', return_value=None)
def test_set_metasploit_globals(
    mock_organizer_init, mock_send_command, mock_log_line
):
    """Test the Organizer.set_metasploit_globals() function
    Arguments:
        mock_organizer_init: patched to not perform constructor
        mock_send_command: patched to not send command
        mock_log_line: patched to not log line
    """
    # Create an Organizer: skip_banner and set_metasploit_globals are patched
    organizer = Organizer(planner=None, mode="system", minimum_score=0.0)
    organizer._lhost = '1.1.1.1'

    # Assert the mocked Organizer.__init__ () was called.
    mock_organizer_init.assert_called()

    organizer._set_metasploit_globals()

    # Assert that the appropriate calls have been made
    calls = [
        mock.call('set EXITFUNC process'),
        mock.call('set LHOST 1.1.1.1'),
    ]
    mock_send_command.assert_has_calls(calls)
    mock_log_line.assert_called()


"""
@mock.patch('datetime.datetime.now')
def test_get_timestamp(mock_now):
    #mock_now.return_value = datetime.datetime(2020, 12, 21, 16, 34, 15, 45737)

    #assert get_timestamp(1) == '12/21/2020 16:34'
    pass
"""
