#!/usr/bin/env python3
#
#  Copyright (C) 2018-2021 Toshiba Corporation and Peraton Labs, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.


import pytest
import unittest
from unittest import mock

from a2p2v.types import AccessClass, Capability
from a2p2v.types import CapabilitySeverity
from a2p2v.planner import Credential
from a2p2v.planner import Planner
from a2p2v.planner import State
from a2p2v.planner import UserRole

from . import sampledata

from .sampledata import sample_config
from .sampledata import sample_network_graph
from .sampledata import sample_hosts_db
from .sampledata import initial_conditions
from .sampledata import goal_conditions


class TestState(unittest.TestCase):
    def test_add_status(self):
        pass

    def test_clear_current_status(self):
        pass

    def test_add_credential(self):
        state = State()

        # Check valid add
        state.add_credential(
            credential_host='host1',
            credential_user_role='none',
            credential_password='mypassword',
            credential_username='user',
        )
        self.assertTrue(len(state.credentials) == 1)
        state.add_credential(
            credential_host='host2',
            credential_user_role='none',
            credential_password='mypassword',
            credential_username='user',
        )
        self.assertTrue(len(state.credentials) == 2)

        # Check that a duplicate is not added
        state.add_credential(
            credential_host='host2',
            credential_user_role='none',
            credential_password='mypassword',
            credential_username='user',
        )
        self.assertTrue(len(state.credentials) == 2)

    def test_get_credential(self):
        state = State()
        state.add_credential(
            credential_host='host1',
            credential_user_role='none',
            credential_password='mypassword',
            credential_username='user',
        )
        state.add_credential(
            credential_host='host2',
            credential_user_role='none',
            credential_password='mypassword',
            credential_username='user',
        )
        state.add_credential(
            credential_host='host2',
            credential_user_role='admin',
            credential_password='s3cure!',
            credential_username='admin',
        )

        # Test not found: host does not exist
        credential = state.get_credential(
            credential_host='host3', min_user_role='none'
        )
        self.assertIsNone(credential)

        # Test successful lookup
        credential = state.get_credential(
            credential_host='host1', min_user_role='none'
        )
        self.assertIsNotNone(credential)

        # Test not found: user does not have high enough permissions
        credential = state.get_credential(
            credential_host='host1', min_user_role='admin'
        )
        self.assertIsNone(credential)

        # Test successful lookup with no minimum user
        credential = state.get_credential(
            credential_host='host2', min_user_role='none'
        )
        self.assertIsNotNone(credential)
        self.assertEqual(credential['username'], 'admin')
        self.assertEqual(credential['password'], 's3cure!')
        self.assertEqual(credential['role'], 'admin')

        # Test successful lookup with no minimum user admin
        credential = state.get_credential(
            credential_host='host2', min_user_role='admin'
        )
        self.assertIsNotNone(credential)
        self.assertEqual(credential['username'], 'admin')
        self.assertEqual(credential['password'], 's3cure!')
        self.assertEqual(credential['role'], 'admin')


class TestCredential(unittest.TestCase):
    def test_constructor(self):
        pass


class TestPlanner(unittest.TestCase):
    """TODO: Add tests for the following
    - check_current_role_goal
    - check_current_status_goal
    - check_new_credential
    - check_role_esc
    - check_target_access
    - check_target_host_goal
    - get_capability_protoport
    - is_duplicate_tree
    - is_goal_host_specific
    - resolve_capability_action
    """

    def get_empty_planner(self):
        return Planner(None, None, None)

    def test_constructor(self):
        planner = Planner(None, None, None)

    def test_hostname_to_ips(self):
        # Create a planner, populating the hosts db
        planner = Planner(
            capabilities=None,
            host_capabilities=sample_hosts_db,
            network_graph=None,
        )

        # Check regular usage
        ip_list = planner.hostname_to_ips('HMI')
        self.assertIn('192.168.20.101', ip_list)
        self.assertIn('192.168.30.101', ip_list)

        # Check with network filter
        ip_list = planner.hostname_to_ips('HMI', '192.168.20')
        self.assertIn('192.168.20.101', ip_list)
        self.assertNotIn('192.168.30.101', ip_list)

        # Check with network filter
        ip_list = planner.hostname_to_ips('DoesNotExist')
        self.assertEqual(len(ip_list), 0)

    def test_ip_to_hostname(self):
        # Create a planner, populating the hosts db
        planner = Planner(
            capabilities=None,
            host_capabilities=sample_hosts_db,
            network_graph=None,
        )

        # Check that we can look up by IP address
        target = planner.ip_to_hostname('192.168.20.101')
        self.assertEqual(target, 'HMI')
        target = planner.ip_to_hostname('192.168.30.101')
        self.assertEqual(target, 'HMI')

        # Check that a name lookup returns the same name
        target = planner.ip_to_hostname('HMI')
        self.assertEqual(target, 'HMI')

    @mock.patch.object(Planner, 'hostname_to_ips')
    def test_host_match(self, mock_hostname_to_ips):
        planner = Planner(
            capabilities=None,
            host_capabilities=sample_hosts_db,
            network_graph=None,
        )
        planner.hostname_to_ips.return_value = []

        # Test: source == destination
        self.assertTrue(planner.host_match('abc', 'abc'))
        mock_hostname_to_ips.assert_not_called()

        # Test: source == '*'
        self.assertTrue(planner.host_match('*', 'abc'))
        calls = [mock.call('*'), mock.call('abc')]
        mock_hostname_to_ips.assert_has_calls(calls, any_order=True)

        # Test: not found
        self.assertFalse(planner.host_match('abc', 'xyz'))
        calls = [mock.call('abc'), mock.call('xyz')]
        mock_hostname_to_ips.assert_has_calls(calls, any_order=True)

        # Add values to hostname_to_ips
        planner.hostname_to_ips.return_value = ['abc']
        self.assertTrue(planner.host_match('abc', 'test'))
        calls = [mock.call('abc'), mock.call('test')]
        mock_hostname_to_ips.assert_has_calls(calls, any_order=True)

    def test_ip_from_nic_node(self):
        planner = Planner(
            capabilities=None,
            host_capabilities=None,
            network_graph=sample_network_graph,
        )
        self.assertEqual(planner.ip_from_nic_node('HMI-1'), '192.168.30.101')

    def test_is_derived(self):
        pass

    def test_get_parent_capabilityID(self):
        pass

    def test_is_passive(self):
        planner = Planner(
            capabilities=None,
            host_capabilities=None,
            network_graph=sample_network_graph,
        )
        self.assertTrue(planner.is_passive('OPC-1'))
        self.assertFalse(planner.is_passive('OPC'))

    def test_is_switch(self):
        pass

    def test_is_nic(self):
        planner = Planner(
            capabilities=None,
            host_capabilities=None,
            network_graph=sample_network_graph,
        )

        # Test nics
        self.assertTrue(planner.is_nic('HMI-1'))
        self.assertTrue(planner.is_nic('HMI-2'))

        # Test non-nics
        self.assertFalse(planner.is_nic('HMI'))
        self.assertFalse(planner.is_nic('OPC'))

    @mock.patch('a2p2v.planner.config')
    def test_set_initial_state(self, mock_config):
        # Patch the config object to return what we want
        mock_config.options.side_effect = sample_config.options
        mock_config.get.side_effect = sample_config.get

        planner = Planner(
            capabilities=None, host_capabilities=None, network_graph=None
        )

        # Create the initial conditions by using the mocks
        # mock_config.options.return_value = initial_conditions.keys()
        # mock_config.get.side_effect = lambda _, condition : initial_conditions[condition]

        # Call initial state
        planner.set_initial_state()

        # Check the initial conditions were set accordingly
        self.assertEqual(planner.state.initial_host, 'ATTACKER')
        self.assertEqual(planner.state.current_host, 'ATTACKER')
        self.assertEqual(planner.state.current_role, 2)
        self.assertEqual(planner.state.current_access, AccessClass.METASPLOIT)
        assert not planner.state.current_status

        # Check that the credentials are correct
        self.assertEqual(len(planner.state.credentials), 2)
        for credential in planner.state.credentials:
            if credential.host == 'GW':
                self.assertEqual(credential.username, 'username')
                self.assertEqual(credential.password, 'password')
                self.assertEqual(credential.role, 'user')
            elif credential.host == '192.168.0.115':
                self.assertEqual(credential.username, 'testuser')
                self.assertEqual(credential.password, 'welcome1')
                self.assertEqual(credential.role, 'user')

    @mock.patch.object(Planner, 'get_capability_protoport')
    @mock.patch.object(Planner, 'check_sensitive')
    @mock.patch.object(Planner, 'get_actions')
    def test_find_all_vulns(
        self,
        mock_get_actions,
        mock_check_sensitive,
        mock_get_capability_protoport,
    ):
        capabilities = sampledata.get_capabilities()
        # Create a planner using the sample hosts db
        planner = Planner(
            capabilities=capabilities,
            host_capabilities=sample_hosts_db,
            network_graph=None,
        )

        # State that HMI has one capability
        planner.host_capabilities['HMI']['capabilities'] = [
            'exploit/windows/smb/ms17_010_psexec'
        ]

        # Mock the return values
        planner.check_sensitive.return_value = None
        planner.get_actions.return_value = [
            {
                'type': 'metasploit',
                'key': 'remote_code_execution',
                'value': 'module=exploit/windows/smb/ms17_010_psexec rhosts=192.168.20.52 lport=4444',
            }
        ]

        planner.get_capability_protoport.return_value = 'TCP/445'

        # Call the method being tested
        planner.find_all_vulns(host='HMI')

        trees = planner.attack_trees

        # Check that at least one result was returned
        self.assertTrue(len(trees) > 0)

        # Get the first tree
        tree = trees[0]

        # Get the capability score
        # {'severity': 4, 'service': 0, 'exploit': 1, 'len': 1, 'combined': 8.2}
        score = tree['score']
        self.assertEqual(score['severity'], 3)
        self.assertEqual(score['services'], 0)
        self.assertEqual(score['exploits'], 1)
        self.assertEqual(score['combined'], 8.4)

        # Get the hops
        hops = tree['hops']
        self.assertTrue(len(hops) > 0)

        # Get the first hop
        hop = hops[0]
        self.assertEqual(hop['node'], 'HMI')
        self.assertTrue(len(hop['options']) > 0)
        option_1 = hop['options'][0]
        self.assertEqual(
            option_1['capability'],
            'MS17-010 EternalRomance/EternalSynergy/EternalChampion SMB Remote Windows Code Execution (TCP/445)'.upper(),
        )
        self.assertEqual(
            option_1['cves'], 'CVE-2017-0143,CVE-2017-0146,CVE-2017-0147'
        )
        self.assertEqual(option_1['solution'], 'Apply Microsoft patches')
        self.assertEqual(
            option_1['severity'].upper(), CapabilitySeverity.HIGH.name
        )
        self.assertEqual(option_1['rank'], 'normal')

        # Get the list of actions
        actions = option_1['actions']
        self.assertTrue(len(actions) > 0)

        # Get the first action
        action = actions[0]
        self.assertEqual(action['type'], 'metasploit')
        self.assertEqual(action['key'], 'remote_code_execution')
        self.assertEqual(
            action['value'],
            'module=exploit/windows/smb/ms17_010_psexec rhosts=192.168.20.52 lport=4444',
        )

    def test_find_all_host_vulns(self):
        # TODO: Move most of the "find_all_vulns" tests here
        pass

    def mock_config_get(self, section, name):
        score_weights = "{'NUM_EXPLOITS':-0.5, 'LENGTH':-0.5, 'NUM_SERVICES':0.2, 'SEVERITY':-0.2}"
        sensitive1 = '{"type":"state", "key":"current_host", "value":"OPC"}'
        sensitive2 = (
            '{"type":"state", "key":"current_status", "value":"change_temp"}'
        )

        if section == 'PLANNING':
            if name == 'score_weights':
                return score_weights

        if section == 'SENSITIVE':
            if name == 'sensitive1':
                return sensitive1
            elif name == 'sensitive2':
                return sensitive2

    def mock_config_options(self, section):
        if section == 'SENSITIVE':
            return ['sensitive1', 'sensitive2']

    @mock.patch('a2p2v.planner.config')
    def test_add_attack_tree(self, mock_config):
        # Patch the config object to retrun what we want
        mock_config.options.side_effect = self.mock_config_options
        mock_config.get.side_effect = self.mock_config_get

        # Create an empty planner
        planner = Planner(
            capabilities=None, host_capabilities=None, network_graph=None
        )

        # Test empty
        self.assertEqual(len(planner.attack_trees), 0)

        default_score = {
            'len': 0,
            'severity': 0,
            'services': 0,
            'exploits': 0,
            'combined': 10.0,
        }

        # Create a dummy hop
        hop = {
            "node": "GW",
            "options": [
                {
                    "capability": "none",
                    "class": "service",
                    "severity": "none",
                    "rank": "normal",
                    "cves": "",
                    "solution": "None.",
                    "actions": [
                        {
                            "type": "metasploit",
                            "key": "parameters",
                            "value": "module=none rhosts=172.16.1.1",
                        }
                    ],
                }
            ],
        }

        hops = [hop]

        # Test identical trees
        attack_tree0 = {
            "hops": hops,
            "score": {},
            "goals": ["change_temperature"],
        }
        attack_tree_dup = {
            "hops": hops,
            "score": default_score,
            "goals": ["change_temperature"],
        }
        planner.add_attack_tree(attack_tree0)

        # The planner should recognize they are identical
        planner.add_attack_tree(attack_tree_dup)
        print(planner.attack_trees)
        self.assertEqual(len(planner.attack_trees), 1)

        attack_tree1 = {
            "hops": [
                {
                    "node": "GW",
                    "options": [
                        {
                            "capability": "SSH (TCP/22)",
                            "class": "service",
                            "severity": "none",
                            "rank": "normal",
                            "cves": "",
                            "solution": "The password for this service may be compromised.  Change it as soon as possible.",
                            "actions": [
                                {
                                    "type": "metasploit",
                                    "key": "parameters",
                                    "value": "module=auxiliary/scanner/ssh/ssh_login rhosts=172.16.1.1 username=username password=password",
                                }
                            ],
                        }
                    ],
                }
            ],
            "score": {
                "len": 1,
                "severity": "low",
                "services": 1,
                "exploits": 1,
                "combined": 1,
            },
            "goals": ["change_temperature"],
        }

        planner.add_attack_tree(attack_tree1)
        self.assertEqual(len(planner.attack_trees), 2)

        # NOTE: 'score' will be different
        self.assertEqual(planner.attack_trees[0]['hops'], attack_tree0['hops'])
        self.assertEqual(
            planner.attack_trees[0]['goals'], attack_tree0['goals']
        )
        self.assertEqual(planner.attack_trees[1]['hops'], attack_tree1['hops'])
        self.assertEqual(
            planner.attack_trees[1]['goals'], attack_tree1['goals']
        )

    def test_find_all_paths_no_mocks(self):
        capabilities = sampledata.get_capabilities()
        # Create a planner using the sample hosts db
        planner = Planner(
            capabilities=capabilities,
            host_capabilities=sample_hosts_db,
            network_graph=sample_network_graph,
        )
        credentials = [
            Credential('GW', 'user', 'username', 'password', None),
            Credential('192.168.0.115', 'user', 'testuser', 'welcome1', None),
        ]

        state = State(current_host='ATTACKER')
        state.initial_host = 'ATTACKER'
        state.current_role = 2
        state.current_access = 4

        state.credentials = credentials

        planner.state = state

        goals = [
            {
                'type': 'state',
                'key': 'current_status',
                'value': 'change_temp',
                'id': 'goal_condition1',
            }
        ]

        planner.goals = goals

        # Set Initial State

        # Set Goals

        # TODO: Write test case for find_all_paths
        empty_tree = {'hops': [], 'score': {}, "goals": set()}

        planner.find_all_paths()

        self.assertTrue(len(planner.attack_trees) > 0)

    @mock.patch.object(Planner, 'add_attack_tree')
    @mock.patch.object(Planner, 'get_actions')
    @mock.patch.object(Planner, 'check_state_change')
    @mock.patch.object(Planner, 'ip_to_hostname')
    @mock.patch.object(Planner, 'ip_from_nic_node')
    @mock.patch.object(Planner, 'is_nic')
    def test_find_all_paths(
        self,
        mock_is_nic,
        mock_ip_from_nic_node,
        mock_ip_to_hostname,
        mock_check_state_change,
        mock_get_actions,
        mock_add_attack_tree,
    ):
        capabilities = sampledata.get_capabilities()
        # Create a planner using the sample hosts db
        planner = Planner(
            capabilities=capabilities,
            host_capabilities=sample_hosts_db,
            network_graph=sample_network_graph,
        )
        state = State(current_host='GW')
        state.initial_host = 'GW'
        state.current_role = None
        state.current_access = 2
        planner.state = state
        planner.passiveRepeats = False

        # TODO: Write test case for find_all_paths
        empty_tree = {
            'hops': [],
            'score': {'severity': 0, 'service': 0, 'exploit': 0},
        }

        # planner.find_all_paths(empty_tree, planner.state, planner.state.initial_host)

        # find_all_paths(self, state, graph, start, tree, path=[], last_interface_ip=None):

    @mock.patch.object(Planner, 'check_goal_reached')
    @mock.patch.object(Planner, 'check_sensitive')
    def test_check_state_change(
        self, mock_check_sensitive, mock_check_goal_reached
    ):
        # Create dummy planner
        planner = Planner(
            capabilities=None, host_capabilities=None, network_graph=None
        )

        # Mock the return values
        planner.check_goal_reached.return_value = (False, True)
        planner.check_sensitive.return_value = False

        # Sample states
        pre_state = State(current_host='HMI')
        pre_state.current_role = 0
        pre_state.current_access = 0

        # Set the post_state and store it in the planner
        post_state = State(current_host='HMI')
        post_state.current_role = 0
        post_state.current_access = 0

        planner.state = post_state

        # Call the method under test
        state_changed = planner.check_state_change(pre_state)

        # Check the arguments
        planner.check_sensitive.assert_called()
        planner.check_goal_reached.assert_called()

        # Verify the return value
        self.assertEqual(state_changed['goal'], (False, True))
        self.assertFalse(state_changed['sensitive'])

    def test_check_sensitive(self):
        pass

    def test_get_actions(self):
        pass

    def test_get_parameter_dict(self):
        metasploit_value = 'module=exploit/windows/smb/ms17_010_psexec rhosts=$target_host lport=4444'
        parameters = Planner.get_parameter_dict(metasploit_value)

        self.assertEqual(
            parameters['module'], 'exploit/windows/smb/ms17_010_psexec'
        )
        self.assertEqual(parameters['rhosts'], '$target_host')
        self.assertEqual(parameters['lport'], '4444')

    def test_resolve_capability_action_does_not_change_capabilities(self):
        capabilities = sampledata.get_capabilities()
        capability_eternal_blue = capabilities[
            'exploit/windows/smb/ms17_010_psexec'
        ]
        planner = Planner(
            capabilities=capabilities,
            host_capabilities=None,
            network_graph=None,
        )

        values = {'rhosts': 'HMI'}
        resolvedActions = []

        # Check the capabilities before calling the method
        capability_actions = capabilities[
            'exploit/windows/smb/ms17_010_psexec'
        ].actions
        capability_parameters = parameters = Planner.get_parameter_dict(
            capability_actions[0]['value']
        )
        self.assertEqual(
            parameters['module'], 'exploit/windows/smb/ms17_010_psexec'
        )
        self.assertEqual(parameters['rhosts'], '$target_host')

        # Call the method
        planner.resolve_capability_action(
            capability_eternal_blue,
            values=values,
            resolved_actions=resolvedActions,
        )
        # Check the capabilities have not changed after calling the method
        capability_actions = capabilities[
            'exploit/windows/smb/ms17_010_psexec'
        ].actions
        capability_parameters = parameters = Planner.get_parameter_dict(
            capability_actions[0]['value']
        )
        self.assertEqual(
            parameters['module'], 'exploit/windows/smb/ms17_010_psexec'
        )
        self.assertEqual(parameters['rhosts'], '$target_host')

    def test_resolve_capability_action_type_metasploit(self):
        capabilities = sampledata.get_capabilities()
        capability_eternal_blue = capabilities[
            'exploit/windows/smb/ms17_010_psexec'
        ]
        planner = Planner(
            capabilities=capabilities,
            host_capabilities=None,
            network_graph=None,
        )

        values = {'rhosts': 'HMI'}
        resolvedActions = []

        # Call the function under test
        planner.resolve_capability_action(
            capability_eternal_blue,
            values=values,
            resolved_actions=resolvedActions,
        )
        self.assertEqual(values, values)
        self.assertEqual(len(resolvedActions), 1)
        actions = resolvedActions[0]

        self.assertEqual(actions['type'], 'metasploit')
        self.assertEqual(actions['key'], 'remote_code_execution')

        # Convert the metasploit parameters to a dictionary
        parameters = Planner.get_parameter_dict(actions['value'])

        # Verify that $target_host was replaced with HMI
        self.assertEqual(
            parameters['module'], 'exploit/windows/smb/ms17_010_psexec'
        )
        self.assertEqual(parameters['rhosts'], 'HMI')
        self.assertEqual(parameters['lport'], '4444')

    def test_resolve_capability_action_type_capability(self):
        capabilities = sampledata.get_capabilities()
        planner = Planner(
            capabilities=capabilities,
            host_capabilities=None,
            network_graph=None,
        )

        values = {'rhost': 'PLC'}
        resolvedActions = []
        capability = capabilities['modbus.write_register.change_temp']

        # Call the function under test
        planner.resolve_capability_action(
            capability, values=values, resolved_actions=resolvedActions
        )
        self.assertEqual(values, values)
        self.assertEqual(len(resolvedActions), 1)
        actions = resolvedActions[0]

        self.assertEqual(actions['type'], 'metasploit')
        self.assertEqual(actions['key'], 'parameters')

        # Convert the metasploit parameters to a dictionary
        parameters = Planner.get_parameter_dict(actions['value'])

        # Verify that $target_host was replaced with PLC
        self.assertEqual(
            parameters['module'], 'auxiliary/scanner/scada/modbusclient'
        )
        self.assertEqual(parameters['rhost'], 'PLC')
        self.assertEqual(parameters['action'], 'WRITE_REGISTERS')
        self.assertEqual(parameters['data_address'], '2')
        self.assertEqual(parameters['data_registers'], '30')
        self.assertEqual(parameters['unit_number'], '255')

    def test_resolve_capability_action_type_shell_command(self):
        capabilities = sampledata.get_capabilities()
        planner = Planner(
            capabilities=capabilities,
            host_capabilities=None,
            network_graph=None,
        )

        values = {
            'username': 'username',
            'password': 'password',
            'target_host': 'OPC',
        }
        resolvedActions = []
        capability = capabilities['rdp']

        # Call the function under test
        planner.resolve_capability_action(
            capability, values=values, resolved_actions=resolvedActions
        )
        self.assertEqual(values, values)
        self.assertEqual(len(resolvedActions), 1)
        actions = resolvedActions[0]

        self.assertEqual(actions['type'], 'shell_command')
        self.assertEqual(actions['key'], 'Remote Desktop')
        self.assertEqual(
            actions['value'], 'rdesktop -u $username -p $password $target_host'
        )

    def test_update_status(self):
        pass

    def test_set_post_conditions(self):
        pass

    def test_get_sensitive_states(self):
        pass

    @mock.patch('a2p2v.planner.config')
    def test_set_goals(self, mock_config):
        # Patch the config object to return what we want
        mock_config.options.side_effect = sample_config.options
        mock_config.get.side_effect = sample_config.get

        # Create an empty planner
        planner = Planner(
            capabilities=None, host_capabilities=None, network_graph=None
        )

        # Call the method under test
        planner.set_goals()

        # Check that the goal was parsed according to what we expect
        self.assertEqual(len(planner.goals), 1)
        self.assertEqual(planner.goals[0]['id'], 'change_temperature')
        self.assertEqual(planner.goals[0]['type'], 'state')
        self.assertEqual(planner.goals[0]['key'], 'current_status')
        self.assertEqual(planner.goals[0]['value'], 'change_temp')

    @mock.patch.object(Planner, 'find_all_paths')
    @mock.patch.object(Planner, 'set_goals')
    @mock.patch.object(Planner, 'set_initial_state')
    @mock.patch('a2p2v.planner.config')
    @mock.patch('a2p2v.planner.sys')
    def test_run_success(
        self,
        mock_sys,
        mock_config,
        mock_set_initial_state,
        mock_set_goals,
        mock_find_all_paths,
    ):
        # Patch the config object to return what we want
        mock_config.options.side_effect = sample_config.options
        mock_config.get.side_effect = sample_config.get

        # Create an empty planner
        planner = Planner(
            capabilities=None, host_capabilities=None, network_graph=None
        )
        state = State(current_host='GW')
        state.initial_host = None
        state.current_role = None
        state.current_access = 2
        planner.state = state

        # Test with all variables supplied
        mock_config.sections.return_value = ['INITIAL CONDITIONS', 'GOALS']
        planner.run_system()
        mock_sys.exit.assert_not_called()
        mock_find_all_paths.assert_called()

        # Check if INITIAL CONDITIONS and GOALS not set
        mock_config.sections.return_value = []
        mock_sys.reset()
        planner.run_system()
        mock_sys.exit.assert_called()

        # Check if GOALS not set
        mock_config.sections.return_value = ['INITIAL CONDITIONS']
        mock_sys.reset()
        planner.run_system()
        mock_sys.exit.assert_called()

        # Check if INITIAL CONDITIONS not set
        mock_config.sections.return_value = ['GOALS']
        mock_sys.reset()
        planner.run_system()
        mock_sys.exit.assert_called()


@pytest.fixture
@mock.patch('a2p2v.planner.config')
def empty_planner(mock_config):
    # Patch the config object to return what we want
    mock_config.options.side_effect = sample_config.options
    mock_config.get.side_effect = sample_config.get

    # Create an empty planner
    planner = Planner(
        capabilities=None, host_capabilities=None, network_graph=None
    )

    return planner


@pytest.fixture
@mock.patch('a2p2v.planner.config')
def planner(mock_config):
    # Get a sample capabilities
    capabilities = sampledata.get_capabilities()

    # Patch the config object to return what we want
    mock_config.options.side_effect = sample_config.options
    mock_config.get.side_effect = sample_config.get

    # Create a planner using the sample hosts db
    planner = Planner(
        capabilities=capabilities,
        host_capabilities=sample_hosts_db,
        network_graph=sample_network_graph,
    )

    return planner


VALID_ESCALATIONS = [
    (AccessClass.NONE, AccessClass.WEB),
    (AccessClass.WEB, AccessClass.SHELL),
]

INVALID_ESCALATIONS = [
    (AccessClass.NONE, AccessClass.NONE),
    (AccessClass.WEB, AccessClass.WEB),
    (AccessClass.WEB, AccessClass.NONE),
]


@pytest.mark.parametrize("before,after", VALID_ESCALATIONS)
def test_check_access_esc_valid(empty_planner, before, after):
    pre_state = State()
    empty_planner.state = State()

    pre_state.current_access = before
    empty_planner.state.current_access = after

    assert empty_planner.check_access_esc(pre_state)


@pytest.mark.parametrize("before,after", INVALID_ESCALATIONS)
def test_check_access_esc_invalid(empty_planner, before, after):
    pre_state = State()
    empty_planner.state = State()

    pre_state.current_access = before
    empty_planner.state.current_access = after

    assert not empty_planner.check_access_esc(pre_state)


SUCCESSFUL_ACCESS_GOALS = [
    ('shell', AccessClass['SHELL'].value, 'OPC', 'OPC'),
    ('shell', AccessClass['SHELL'].value, 'OPC', '*'),
]


@pytest.mark.parametrize(
    "goal_access, current_access, goal_host, current_host",
    SUCCESSFUL_ACCESS_GOALS,
)
def test_check_current_access_goal(
    planner, goal_access, current_access, goal_host, current_host
):
    planner.state = State()
    planner.state.current_host = current_host
    planner.state.current_access = current_access

    assert planner.check_current_access_goal(goal_access, goal_host)


SUCCESSFUL_HOST_GOALS = [
    ('OPC', 'OPC'),
    ('HMI', 'HMI'),
    ('192.168.30.101', 'HMI'),
    ('HMI', '192.168.30.101'),
    ('192.168.20.104', 'OPC'),
    ('OPC', '192.168.20.104'),
]


@pytest.mark.parametrize("goal_host, current_host", SUCCESSFUL_HOST_GOALS)
def test_check_current_host_goal(planner, goal_host, current_host):
    planner.state = State()
    planner.state.current_host = current_host
    assert planner.check_current_host_goal(goal_host)


def test_check_current_host_goal_false(planner):
    planner.state = State()
    planner.state.current_host = 'HMI'
    assert not planner.check_current_host_goal('OPC')


SUCCESSFUL_PRECONDITIONS = [
    # current_host, current_access, target_host, capability
    ('OPC', AccessClass.SHELL, 'PLC', 'modbus'),
    ('OPC', AccessClass.SHELL, 'PLC', 'modbus.write_register'),
    ('OPC', AccessClass.SHELL, 'PLC', 'modbus.write_register.change_temp'),
    # Privilege escalation
    ('HMI', AccessClass.SHELL, 'HMI', 'privilege_escalation'),
    # Strange case #2: Most exploits have no preconditions
    # And because they have no preconditions, test_preconditions always returns True
    (None, None, 'DoesNotMatter', 'remote_code_execution'),
    (None, None, 'DoesNotMatter', 'exploit/windows/smb/ms17_010_psexec'),
    (None, None, 'DoesNotMatter', 'exploit/windows/smb/ms10_061_spoolss'),
]


UNSUCCESSFUL_PRECONDITIONS = [
    # current_host, current_access, target_host, capability
    # The following seems like they should instead be False
    # Strange case #2: Most exploits have no preconditions
    # And because they have no preconditions, test_preconditions always returns True
    (None, None, 'DoesNotMatter', 'remote_code_execution'),
    (None, None, 'DoesNotMatter', 'exploit/windows/smb/ms17_010_psexec'),
    (None, None, 'DoesNotMatter', 'exploit/windows/smb/ms10_061_spoolss'),
]


UNSUCCESSFUL_PRECONDITIONS = [
    # current_host, current_access, target_host, capability
    # Check modbus False
    (None, None, 'PLC', 'modbus'),
    (None, None, 'PLC', 'modbus.write_register.change_temp'),
    (None, None, 'PLC', 'modbus.write_register'),
    # smb, rdp, ssh without credentials
    (None, None, 'OPC', 'smb'),
    (None, None, 'OPC', 'rdp'),
    (None, None, 'GW', 'ssh'),
    ('OPC', AccessClass.SHELL, 'OPC', 'smb'),
    ('OPC', AccessClass.SHELL, 'OPC', 'rdp'),
    ('GW', AccessClass.SHELL, 'GW', 'ssh'),
    # Privilege escalation with no access
    (None, None, 'HMI', 'privilege_escalation'),
]


@pytest.mark.parametrize(
    'current_host,current_access,target_host,capability',
    SUCCESSFUL_PRECONDITIONS,
)
def test_test_preconditions(
    planner, current_host, current_access, target_host, capability
):
    capabilities = sampledata.get_capabilities()

    planner.state = State(current_host=current_host)
    planner.state.current_access = current_access

    assert planner.test_preconditions(target_host, capabilities[capability])


@pytest.mark.parametrize(
    'current_host,current_access,target_host,capability',
    UNSUCCESSFUL_PRECONDITIONS,
)
def test_test_preconditions_false(
    planner, current_host, current_access, target_host, capability
):
    capabilities = sampledata.get_capabilities()

    planner.state = State(current_host=current_host)
    planner.state.current_access = current_access

    assert not planner.test_preconditions(
        target_host, capabilities[capability]
    )


CREDENTIAL_PRECONDITIONS = [
    # current_host,cred_host, cred_role,cred_user,cred_password,target_host,capability,result
    ('HMI', 'OPC', 'user', 'username', 'password', 'OPC', 'smb', True),
    ('HMI', 'OPC', 'user', 'username', 'password', 'OPC', 'rdp', True),
    ('attacker', 'GW', 'admin', 'guest', 'welcome1', 'GW', 'ssh', True),
    # User is on the OPC machine, has credentials for OPC, and wants to access the gateway
    ('OPC', 'OPC', 'user', 'username', 'password', 'GW', 'ssh', False),
]


@pytest.mark.parametrize(
    'current_host,cred_host, cred_role,cred_user,cred_password,target_host,capability,result',
    CREDENTIAL_PRECONDITIONS,
)
def test_test_precondition_credentials(
    planner,
    current_host,
    cred_host,
    cred_role,
    cred_user,
    cred_password,
    target_host,
    capability,
    result,
):
    capabilities = sampledata.get_capabilities()

    planner.state = State(current_host=current_host)
    planner.state.current_access = AccessClass.SHELL
    planner.state.add_credential(
        cred_host, cred_role, cred_user, cred_password
    )

    assert (
        planner.test_preconditions(target_host, capabilities[capability])
        is result
    )


SUCCESSFUL_GOAL_REACHED = [
    # goal_key, goal_value, current_host, current_status, current_access, is_host_found, has_results
    # Test #1: Check no matches
    (None, None, None, None, None, True, False),
    # Test #2: Check goal "current_host"
    ('current_host', 'OPC', 'OPC', 'current_host', None, True, True),
    # Test #3: Check goal "current_status" -> "reachable"
    ('current_host', 'reachable', 'OPC', 'reachable', None, True, True),
    # Test #4: Check goal "current_status" -> "change_temp"
    ('current_status', 'change_temp', 'PLC', 'change_temp', None, True, True),
    # Test #5: Check goal "current_access"
    ('current_access', 'shell', 'HMI', AccessClass.SHELL, None, True, False),
]


@pytest.mark.parametrize(
    'goal_key,goal_value,current_host,current_status,current_access,is_host_found,has_results',
    SUCCESSFUL_GOAL_REACHED,
)
@mock.patch.object(Planner, 'host_match')
def test_check_goal_reached(
    mock_host_match,
    planner,
    goal_key,
    goal_value,
    current_host,
    current_status,
    current_access,
    is_host_found,
    has_results,
):
    planner.state = State(
        current_host=current_host, current_status=current_status
    )
    planner.state.currentAccess = current_access
    planner.host_match.return_value = is_host_found
    goal_id = 'test'
    planner.goals = [{'id': goal_id, 'key': goal_key, 'value': goal_value}]

    # Call the function under test
    result = planner.check_goal_reached()
    if has_results:
        # planner.host_match.assert_called_with('*', 'PLC')
        # planner.host_match.assert_called_with('*', 'HMI')
        assert result
        assert goal_id in result
        assert planner.state.current_status == current_status
    else:
        assert result is None
