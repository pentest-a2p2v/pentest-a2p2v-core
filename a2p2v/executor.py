#!/usr/bin/env python3
# SPDX-License-Identifier: Apache-2.0
# SPDX-FileCopyrightText: Copyright 2018-2023 Toshiba Corporation and Peraton Labs, Inc.
# See README.md for license details

""" This module is an additional layer on top of the Metasploit RPC API.
    Currently, it is being used to simulate reading and writing.
    In the near future, an additional Executor class will be added to
    directly interact with the actual Metasploit API.
"""

import logging
import queue
import time

from pymetasploit3.msfrpc import MsfRpcClient

from a2p2v.config import config

logger = logging.getLogger(__name__)


class Executor:
    """This class interacts with the Metasploit API to execute attacks"""
    def __init__(self, verbose: bool = True):
        """Connect to the Metasploit RPC and create a console"""
        self._console = None
        self._console_id = None
        self._client = None

        if not self._connect_client():
            self.valid = False
        else:
            self.valid = True

        self._verbose = verbose

    def _connect_client(self):
        # Obtain the Metasploit API parameters from the configuration
        host = config['METASPLOIT']['host']
        user = config['METASPLOIT']['user']
        password = config['METASPLOIT']['password']
        port = int(config['METASPLOIT']['port'])

        try:
            self.client = MsfRpcClient(server=host, user=user, password=password, port=port)
            return True
        except Exception as e:
            logger.error("Unable to connect to Metasploit API: {}".format(e))
            logger.error("Will not be able to perform actual execution, only simulated")
            return False

    def destroy_console(self):
        """Close the console"""
        logger.debug('_destroy_console(): called')
        if self._console is not None:
            self._console.destroy()
            self._console_id = None
            self._console = None
    
    def _create_console(self):
        """Create a metasploit console
        """
        if self._console_id is None:
            self._console = self.client.consoles.console()
            self._console_id = self._console.cid

    def write(self, message, delay_time_seconds=None):
        """Write to the existing console"""
        if self._console_id is None or self._console is None:
            self._create_console()

        logger.info("Writing message: '%s'", message)
        print(f'metasploit > {message}')
        _ = self._console.write(message)

        if delay_time_seconds is not None:
            self.delay(delay_time_seconds)

    def read(self):
        """Read from the console"""
        if self._console_id is None or self._console is None:
            self._create_console()

        response = self._console.read()
        data = response.get('data')
        if data:
            print(data.strip())
        logger.info("Read response: '%s'", response)
        return response

    def delay(self, time_seconds=1):
        """Sleep a specified amount of time:
        Arguments:
            time_seconds (int): time to sleep in seconds
        """
        time.sleep(time_seconds)

    def stop_session(self, session_number):
        """Stop a meterpreter or other session
        Arguments:
            session_number (int): the meterpreter session number to stop
        """
        logger.debug('Stopping session #{}'.format(session_number))
        shell = self.client.sessions.session(session_number)
        shell.stop()

    def stop_all_sessions(self):
        """Stop all meterpreter or other sessions"""
        if self.client:
            for session_number in self.client.sessions.list.keys():
                self.stop_session(session_number)

    def ready(self):
        """Return true if authenticated to the Metasploit RPC API"""
        return self.valid


class Simulator:
    """The simulator pretends to interact with the Metasploit API.
    Based on the command that is sent, an appropriate response
    messages is appended to the queue.
    In the case of a "run" statement, a separate queue is used
    to keep track of the exploit name that was used
    """

    _prompt = 'msf5 simulator> '

    def __init__(self, verbose: bool = False):
        """Simulator class provides all the same methods as Executor"""
        # Create a new metasploit client
        self._console = None
        self._console_id = None
        self.client = "FakeClient"

        self.valid = True
        self._responses = queue.SimpleQueue()
        self._run_responses = queue.SimpleQueue()
        self._session_num = 0

        self._add_response('Metasploit Started\n')
        self._verbose = verbose

    @classmethod
    def ready(cls):
        """The simulator is always ready"""
        return True

    def destroy_console(self):
        """Remove the current metasploit console"""
        self._console_id = None
        logger.debug('_destroy_console(): called')

    def _create_console(self):
        """Create a metasploit console"""
        self._console_id = 0

    def write(self, message, delay_time_seconds=None):
        """Write a message to the metasploit console
        Arguments:
            message (str): the message to send to metasploit
            delay_time_seconds (int): ignored
        """
        logger.debug('Writing message: \'%s\'', message)

        if 'exploit' in message:
            self._session_num += 1
            self._add_run_response(
                '\n[*] Executing exploit\n[+] '
                f'Meterpreter session {self._session_num} opened'
            )
        elif 'sessions -u' in message:
            self._session_num += 1
            self._add_response(
                '\n[*] Executing post/multi/manage/shell_to_meterpreter\n',
                busy=True,
            )
            self._add_response(busy=True)
            self._add_response(
                f'\n[*] Meterpreter session {self._session_num} opened\n',
                busy=True,
            )
        elif 'sessions' in message:
            _, session_num = message.split(' ')
            self._add_response(
                f'\n[*] Activating session {session_num}\n', busy=False
            )
        elif 'ssh' in message:
            self._session_num += 1
            self._add_run_response(
                '\n[+] Success\n[+] Command shell session '
                f'{self._session_num} opened'
            )
        elif 'set' in message:
            _, name, value = message.split(' ')
            self._add_response(f'{name} => {value}\n')
        elif 'auxiliary' in message:
            self._add_run_response(
                '\n[*] Succeeded\n[*] Auxiliary module execution completed'
            )
        elif message == 'run post/multi/manage/autoroute':
            self._add_response('\n[+] Route added.\n')
        elif message == 'bg':
            self._add_response(
                f'\n[*] Backgrounding session {self._session_num}.\n'
            )
        elif 'run' in message or 'exploit' in message:
            self._add_response('Simulated run', busy=True)

        if delay_time_seconds is not None:
            self.delay(delay_time_seconds)

    def _add_response(
        self, msg: str = '', prompt: str = None, busy: bool = False
    ):
        if not prompt:
            prompt = self._prompt
        response = self._format_response(msg, prompt, busy)
        logger.debug('_add_response %s', response)
        self._responses.put(response)

    def _add_run_response(
        self, msg: str = '', prompt: str = None, busy: bool = False
    ):
        if not prompt:
            prompt = self._prompt
        response = self._format_response(msg, prompt, busy)
        logger.debug('_add_run_response %s', response)
        self._run_responses.put(response)

    def _format_response(
        self, msg: str = '', prompt: str = None, busy: bool = False
    ) -> dict:
        if not prompt:
            prompt = self._prompt
        response = {'data': msg, 'prompt': prompt, 'busy': busy}
        return response

    def _get_response(self):
        if not self._responses.empty():
            msg = self._responses.get_nowait()
            if msg is None:
                logger.error('Found None on response queue')
        else:
            logger.debug('Empty response')
            msg = {'data': '', 'prompt': self._prompt, 'busy': False}

        return msg

    def read(self):
        """Read the response from the message queue
        Returns:
            dict: Response from metasploit API
                  dictionary containing 'data' and 'prompt'
        """

        response = self._get_response()

        logger.debug('read(): response = %s', response)
        if response and response.get('data', '') == 'Simulated run':
            while not self._run_responses.empty():
                new_response = self._run_responses.get_nowait()
                logger.debug('Adding response %s', new_response)
                if new_response:
                    self._responses.put(new_response)

        logger.debug('Read message %s', response)

        return response

    def delay(self, time_seconds=1):
        """Sleep a specified amount of time:
        Arguments:
            time_seconds (int): time to sleep in seconds
        """

    def stop_session(self, session_number):
        """Stop a meterpreter or other session
        Arguments:
            session_number (int): the meterpreter session number to stop
        """
        if self._console is not None:
            logger.debug('Stopping session #%s', session_number)

    def stop_all_sessions(self):
        """Stop all meterpreter or other sessions"""


def main():
    """Simple example running the simulator"""
    simulator = Simulator()
    print(simulator.read())
    for command in [
        'use xxx',
        'set RHOST localhost',
        'run',
        'sessions -u',
        'bg',
    ]:
        simulator.write(command)
        print(simulator.read())

    print(simulator.read())


if __name__ == '__main__':
    main()
