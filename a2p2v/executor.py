#!/usr/bin/env python3
#
#  Copyright (C) 2018-2021 Toshiba Corporation and Peraton Labs, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

""" This module is an additional layer on top of the Metasploit RPC API.
    Currently, it is being used to simulate reading and writing.
    In the near future, an additional Executor class will be added to
    directly interact with the actual Metasploit API.
"""

import logging
import queue
import time

from .msfrpc import MsfRpcClient

logger = logging.getLogger(__name__)


class Executor:
    """This class interacts with the Metasploit API to execute attacks"""
    def __init__(self, verbose: bool = True):
        """Connect to the Metasploit RPC and create a console"""
        self.valid = True
        self._client = MsfRpcClient()
        self._console = self._client.create_console()
        self._verbose = verbose

    def destroy_console(self):
        """Close the console"""
        self._console.destroy()

    def write(self, message, delay_time_seconds=None):
        """Write to the existing console"""
        logger.info("Writing message: '%s'", message)
        _ = self._console.write(message, echo=self._verbose)

        if delay_time_seconds is not None:
            time.sleep(delay_time_seconds)

    def read(self):
        """Read from the console"""
        response = self._console.read(echo=self._verbose)
        logger.info("Read response: '%s'", response)
        return response

    def stop_all_sessions(self):
        """Stop all Meterpreter and shell sessions"""
        self._client.stop_all_sessions()

    def ready(self):
        """Return true if authenticated to the Metasploit RPC API"""
        return self._client.is_connected()


class Simulator:
    """The simulator pretends to interact with the Metasploit API.
    Based on the command that is sent, an appropriate response
    messages is appended to the queue.
    In the case of a "run" statement, a separate queue is used
    to keep track of the exploit name that was used
    """

    _prompt = 'msf5 simulator> '

    def __init__(self, verbose: bool = False):
        """Simulator class provides all the same methods as Executor"""
        # Create a new metasploit client
        self._console = None
        self._console_id = None
        self.client = "FakeClient"

        self.valid = True
        self._responses = queue.SimpleQueue()
        self._run_responses = queue.SimpleQueue()
        self._session_num = 0

        self._add_response('Metasploit Started\n')
        self._verbose = verbose

    @classmethod
    def ready(cls):
        """The simulator is always ready"""
        return True

    def destroy_console(self):
        """Remove the current metasploit console"""
        self._console_id = None
        logger.debug('_destroy_console(): called')

    def _create_console(self):
        """Create a metasploit console"""
        self._console_id = 0

    def write(self, message, delay_time_seconds=None):
        """Write a message to the metasploit console
        Arguments:
            message (str): the message to send to metasploit
            delay_time_seconds (int): ignored
        """
        logger.debug('Writing message: \'%s\'', message)

        if 'exploit' in message:
            self._session_num += 1
            self._add_run_response(
                '\n[*] Executing exploit\n[+] '
                f'Meterpreter session {self._session_num} opened'
            )
        elif 'sessions -u' in message:
            self._session_num += 1
            self._add_response(
                '\n[*] Executing post/multi/manage/shell_to_meterpreter\n',
                busy=True,
            )
            self._add_response(busy=True)
            self._add_response(
                f'\n[*] Meterpreter session {self._session_num} opened\n',
                busy=True,
            )
        elif 'sessions' in message:
            _, session_num = message.split(' ')
            self._add_response(
                f'\n[*] Activating session {session_num}\n', busy=False
            )
        elif 'ssh' in message:
            self._session_num += 1
            self._add_run_response(
                '\n[+] Success\n[+] Command shell session '
                f'{self._session_num} opened'
            )
        elif 'set' in message:
            _, name, value = message.split(' ')
            self._add_response(f'{name} => {value}\n')
        elif 'auxiliary' in message:
            self._add_run_response(
                '\n[*] Succeeded\n[*] Auxiliary module execution completed'
            )
        elif message == 'run post/multi/manage/autoroute':
            self._add_response('\n[+] Route added.\n')
        elif message == 'bg':
            self._add_response(
                f'\n[*] Backgrounding session {self._session_num}.\n'
            )
        elif 'run' in message or 'exploit' in message:
            self._add_response('Simulated run', busy=True)

        if delay_time_seconds is not None:
            self.delay(delay_time_seconds)

    def _add_response(
        self, msg: str = '', prompt: str = None, busy: bool = False
    ):
        if not prompt:
            prompt = self._prompt
        response = self._format_response(msg, prompt, busy)
        logger.debug('_add_response %s', response)
        self._responses.put(response)

    def _add_run_response(
        self, msg: str = '', prompt: str = None, busy: bool = False
    ):
        if not prompt:
            prompt = self._prompt
        response = self._format_response(msg, prompt, busy)
        logger.debug('_add_run_response %s', response)
        self._run_responses.put(response)

    def _format_response(
        self, msg: str = '', prompt: str = None, busy: bool = False
    ) -> dict:
        if not prompt:
            prompt = self._prompt
        response = {'data': msg, 'prompt': prompt, 'busy': busy}
        return response

    def _get_response(self):
        if not self._responses.empty():
            msg = self._responses.get_nowait()
            if msg is None:
                logger.error('Found None on response queue')
        else:
            logger.debug('Empty response')
            msg = {'data': '', 'prompt': self._prompt, 'busy': False}

        return msg

    def read(self):
        """Read the response from the message queue
        Returns:
            dict: Response from metasploit API
                  dictionary containing 'data' and 'prompt'
        """

        response = self._get_response()

        logger.debug('read(): response = %s', response)
        if response and response.get('data', '') == 'Simulated run':
            while not self._run_responses.empty():
                new_response = self._run_responses.get_nowait()
                logger.debug('Adding response %s', new_response)
                if new_response:
                    self._responses.put(new_response)

        logger.debug('Read message %s', response)

        return response

    def delay(self, time_seconds=1):
        """Sleep a specified amount of time:
        Arguments:
            time_seconds (int): time to sleep in seconds
        """

    def stop_session(self, session_number):
        """Stop a meterpreter or other session
        Arguments:
            session_number (int): the meterpreter session number to stop
        """
        if self._console is not None:
            logger.debug('Stopping session #%s', session_number)

    def stop_all_sessions(self):
        """Stop all meterpreter or other sessions"""


def main():
    """Simple example running the simulator"""
    simulator = Simulator()
    print(simulator.read())
    for command in [
        'use xxx',
        'set RHOST localhost',
        'run',
        'sessions -u',
        'bg',
    ]:
        simulator.write(command)
        print(simulator.read())

    print(simulator.read())


if __name__ == '__main__':
    main()
