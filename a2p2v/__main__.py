#!/usr/bin/python3
#
#  Copyright (C) 2018-2021 Toshiba Corporation and Peraton Labs, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

""" This is the main entry point for the command line tool.
    This module allows a user to run the command "a2p2v" along with
    other command line parameters to launch the tool in system planning
    or single-host execution mode.
    A full help can be obtained by running: a2p2v --help
"""

import argparse
import os
import json
import logging
import sys
from typing import Dict, List, Set

from .common import get_file_timestamp
from .organizer import Organizer
from .analyzer import Analyzer
from .planner import Planner
from .database import import_db_from_file
from .metasploitdb import MetasploitDB
from .version import __version__

from .common import configure_logging, set_log_level

LOG_LEVELS = ['ERROR', 'WARNING', 'INFO', 'DEBUG']

logger = logging.getLogger('a2p2v')


def parse_args():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        'a2p2v', description='A2P2V Version {}'.format(__version__)
    )
    parser.add_argument(
        '-v',
        '--verbose',
        action='count',
        default=0,
        help='Use to display more detailed logging',
    )  # Always show error, warning and info
    parser.add_argument(
        '-nx',
        '--netfile',
        help='Network Description File (Required for System Mode Planning)',
        dest='netfile',
        default=None,
        required=False,
    )
    parser.add_argument(
        '-f',
        '--datafile',
        help='Scan data file to use (Nessus, NMAP, Common)',
        required=False,
    )

    group = parser.add_mutually_exclusive_group(required=False)
    group.add_argument(
        '-t',
        '--target',
        help='Choose a target to run in single host mode.  '
        'If omitted all hosts are used',
    )
    group.add_argument(
        '-p',
        '--plan',
        default=False,
        action='store_true',
        help='Run in system planning mode to generate attack '
        'trees based on initial conditions and goal',
    )

    parser.add_argument(
        '--goal-name',
        default=None,
        help='Set the goal name.  Overrides configuration'
    )

    parser.add_argument(
        '--goal-current-status',
        default=None,
        help='Set a current status goal.  Overrides configuration'
    )

    parser.add_argument(
        '--initial-host',
        default=None,
        help='Set the initial host.  Overrides configuration'
    )

    parser.add_argument(
        '--goal-current-host',
        default=None,
        help='Set a current host goal.  Overrides configuration'
    )

    parser.add_argument(
        '--goal-target-host',
        default=None,
        help='Set a target host goal.  Overrides configuration'
    )

    parser.add_argument(
        '-x',
        '--execute',
        help='Perform actual execution rather than simulated',
        default=False,
        action='store_true',
    )
    parser.add_argument(
        '-s',
        '--showgraph',
        help='Display visualizations (Network Representation, '
        'Combined Attack Tree, Execution Progress)',
        default=False,
        action='store_true',
    )
    parser.add_argument(
        '-lh',
        '--lhost',
        help='Manually Set LHOST in Metasploit (IP address of attacker) '
        'if not correctly detected',
        dest='lhost',
        default='172.16.1.200',
        required=False,
    )
    parser.add_argument(
        '-lt',
        '--loadtrees',
        help='Specify a json file with precomputed attack trees '
        'to load (skips analysis and planning)',
        required=False,
    )
    parser.add_argument(
        '-sw',
        '--switchvisits',
        help='Set how many times each switch can be visited in an attack tree',
        required=False,
        default=1,
        type=int,
    )
    parser.add_argument(
        '-mh',
        '--maxhops',
        help='Set the maximum number of hops allowed per attack tree',
        required=False,
        default=5,
        type=int,
    )
    parser.add_argument(
        '-tn',
        '--treenum',
        help='Specify attack tree number to execute if already known',
        type=int,
        required=False,
    )
    parser.add_argument(
        '-ms',
        '--minscore',
        help='Specify a minimum score for attack trees '
        'to display during selection',
        required=False,
    )
    parser.add_argument(
        '-r',
        '--reload',
        default=False,
        dest="reload_cache",
        action='store_true',
        help='Reload the Metasploit cache',
        required=False,
    )
    parser.add_argument(
        '--postexecutescript',
        default=None,
        dest='post_execute_script',
        required=False,
        help='Optional: script to execute after each execution',
    )
    parser.add_argument(
        '-db',
        '--importdb',
        help='Import an XML formatted file into the database',
        dest='dbfile',
        default=None,
        required=False,
    )
    parser.add_argument(
        '--sleep',
        help='Number of seconds to sleep when communicating with Metasploit',
        dest='sleep_seconds',
        type=float,
        default=1.0,
        required=False,
    )
    # parser.add_argument(
    #   '-bb',
    #   '--blackbox',
    #   help='Operate in blackbox mode (not currently supported)',
    #   default=False,
    #   action='store_true'
    # )

    return parser.parse_args()


def main():
    """Parse command line arguments and run various components."""
    args = parse_args()
    target = None

    configure_logging()

    if args.verbose > 0:
        set_log_level(logger, args.verbose + 1)

    # Clean the cache
    if args.reload_cache:
        MetasploitDB.clean()

    # Import the capabilities database
    if args.dbfile is not None:
        import_db_from_file(args.dbfile)
        return

    if args.loadtrees:
        # Load previously created attack trees
        planner = _load_trees(args)
    else:
        # Run the analyzer and planner
        analyzer, target = run_analyzer(args)
        planner = _run_planner(analyzer, args, target)

    _run_organizer(args, planner, target)

    logger.info("Exiting")


def _run_organizer(args, planner, target):
    """Run the organizer, which simulates or executes the attack steps"""
    data_to_report = None
    # Determine the mode
    if args.plan:
        mode = 'system'
    # elif args.blackbox:
    #    mode = 'black'
    else:
        mode = 'single'

    if args.minscore:
        minimum_score = args.minscore
    else:
        minimum_score = False

    organizer = Organizer(
        planner,
        mode,
        minimum_score,
        visualizations=args.showgraph,
        execute=args.execute,
        post_execute_script=args.post_execute_script,
        lhost=args.lhost,
        sleep_seconds=args.sleep_seconds,
    )
    if not os.path.exists('reports'):
        os.makedirs('reports')
    filename_timestamp = get_file_timestamp()
    if not args.loadtrees and planner.attack_trees:
        _write_attack_trees(planner.attack_trees, filename_timestamp)
    # If a target is specified, operate in single-host mode
    # for the target host only
    if target is not None:
        data_to_report = organizer.launch(
            args.treenum, targets=[target.upper()]
        )
    # If a target is not specified and planning is not selected
    # Then operate in single-host mode for all hosts
    elif not args.plan:
        data_to_report = organizer.launch(
            args.treenum, targets=get_hosts_from_trees(planner.attack_trees)
        )
    # If planning is selected
    # Then operate in system planning mode for all hosts
    # (not yet fully supported)
    elif args.plan:
        data_to_report = organizer.launch(args.treenum)

    if data_to_report:
        organizer.create_report(args.plan)


def _run_planner(analyzer, args, target):
    planner = Planner(
        analyzer.capabilities,
        analyzer.host_capabilities,
        analyzer.network_graph,
        args.switchvisits,
        args.maxhops
    )
    if args.plan:
        logger.info("Planning will be performed")
        planner_goal = {"id":args.goal_name, "type":"state"}
        if args.goal_current_status:
            planner_goal["key"] = "current_status"
            planner_goal["value"] = args.goal_current_status
            if not args.goal_name:
                planner_goal["id"] = args.goal_current_status
        elif args.goal_current_host:
            planner_goal["key"] = "current_host"
            planner_goal["value"] = args.goal_current_host
            if not args.goal_name:
                planner_goal["id"] = 'intrude_' + args.goal_current_host
        elif args.goal_target_host:
            planner_goal["key"] = "target_host"
            planner_goal["value"] = args.goal_target_host
            if not args.goal_name:
                planner_goal["id"] = 'target_' + args.goal_target_host

        logger.info('args = %s', args)
        planner.run_system(planner_goal, initial_host=args.initial_host)
        logger.info("Planning complete")
    else:
        logger.info("Planning will not be performed")
        planner.run_single(target)

    return planner


def run_analyzer(args):
    analyzer = Analyzer(
        args.execute,
        args.plan,
        datafile=args.datafile,
        netfile=args.netfile,
    )
    if not analyzer.valid:
        _exit_on_error("Analysis failed to initialize.")
    analyzer_status = analyzer.run()
    if not analyzer_status:
        _exit_on_error("Analysis did not complete successfully")
    else:
        logger.info("Analysis completed successfully")
    if args.target:
        target = analyzer.ip_to_hostname(args.target)
        if target not in analyzer.host_capabilities.keys():
            _exit_on_error(f"Target host {target} is unknown")
    else:
        target = None
    return analyzer, target


def _write_attack_trees(attack_trees, filename_timestamp):
    """Write the attack trees to an output file."""

    attack_trees_filename = "reports/attack_trees_{}.json".format(
        filename_timestamp
    )
    with open(attack_trees_filename, 'w') as f_attack_trees:
        f_attack_trees.write(json.dumps(attack_trees, indent=2))
    logger.info("Attack trees written to: %s", attack_trees_filename)
    print(f'Attack trees written to: {attack_trees_filename}')


def _load_trees(args):
    """If loadtrees parameter is specified, load the corresponding tree"""
    try:
        with open(args.loadtrees, 'r') as trees_fp:
            attack_trees = json.load(trees_fp)
    except FileNotFoundError as error:
        logger.exception(error)
        _exit_on_error(f"Could not find file {args.loadtrees}")

    except json.JSONDecodeError as error:
        logger.exception(error)
        _exit_on_error(f"Could not decode json in file {args.loadtrees}")

    if 'goals' not in attack_trees[0].keys() and args.plan:
        _exit_on_error(
            "Planning specified, but loaded trees are "
            "for single host mode.  Cannot continue."
        )
    if 'goals' in attack_trees[0].keys() and not args.plan:
        _exit_on_error(
            "Planning not specified, but loaded trees are "
            "for system planning mode.  Cannot continue."
        )
    return Planner.preloaded_planner(attack_trees)


def _exit_on_error(error_msg: str):
    """Exit the program when an error occurs.
    Log the message and exit with an error return code.
    Arguments:
        error_msg(str): the error message
    """
    logger.error(error_msg)
    sys.exit(error_msg)


def get_hosts_from_trees(tree_list: List[Dict]) -> Set:
    """Retrieve the unique set of hosts from attack trees
    Arguments:
        tree_list(list): attack trees
    Returns:
        set: unique host names
    """
    hosts = {
        hop['node']
        for attack_tree in tree_list
        for hop in attack_tree.get('hops', [])
    }
    return hosts


if __name__ == "__main__":
    main()
