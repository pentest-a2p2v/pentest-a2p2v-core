#!/usr/bin/env python3
#
#  Copyright (C) 2018-2021 Toshiba Corporation and Perspecta Labs, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""This module is used to query Metasploit module information.
   The first time it runs, it creates a configuration file:
   $HOME/.config/a2p2v/metasploit_config.json

   This file contains the default options as specified by Metasploit.
   The file can be modified to use different options.

   By default, a small subset of Metasploit modules are used.
   To re-create the file with the full set of modules:
   a2p2v --reload
"""

from collections import defaultdict
from collections import namedtuple
import json
import logging
import os
from typing import Dict, List, Set

from .config import get_config_dir
from .config import config
from .msfrpc import MsfRpcClient

METASPLOIT_CONFIG_FILENAME = 'metasploit_config.json'

logger = logging.getLogger(__name__)


MetasploitInfo = namedtuple(
    'MetasploitInfo',
    [
        'module',
        'name',
        'rank',
        'arch',
        'module_type',
        'description',
        'targets',
    ],
)


class MetasploitDB:
    """Provide functions to query Metasploit."""

    data = None

    def __new__(cls):
        """This is a singleton class, use MetasploitDB.methodname"""
        raise Exception('Cannot instantiate singleton class')

    @classmethod
    def _get_db_filename(cls, filename):
        """Get the full path and name of the configuration file
        On Linux, this is $HOME/.config/a2p2v/metasploit_config.json
        Returns:
            str: full path and name of the metasploit config file
        """
        return os.path.join(get_config_dir(), filename)

    @classmethod
    def load_data(cls):
        """Retrieve the data from storage into internal structures"""
        cls.load_broken_modules()
        cls.load_details()

    @classmethod
    def load_broken_modules(cls):
        """Read the list of broken modules from config"""
        cls.broken_modules = set()
        broken_modules = (
            config.get('METASPLOIT', 'broken_modules', fallback='None')
            .replace('"', '')
            .replace("'", "")
        )

        for broken_module in broken_modules.split(' '):
            logger.info('Broken module %s', broken_module)
            cls.broken_modules.add(broken_module)

    @classmethod
    def sanitize(cls, value: str) -> str:
        """Sanitize a string by removing quotes and empty spaces
        Arguments:
            value (str): a string
        Returns:
            str: string without quotes and spaces
        """
        return value.replace("'", "").replace('"', '').strip()

    @classmethod
    def load_details(cls, only_allowed_modules=True):
        """Load the Metasploit details into internal structures
        Arguments:
            only_allowed_modules (bool): If True, only load a subset of modules
        """
        # Get the name of the DB details file
        details_db_filename = cls._get_db_filename(METASPLOIT_CONFIG_FILENAME)

        # If the config file does not exist, pull it using the Metasploit API
        if not os.path.isfile(details_db_filename):
            logger.info(
                "Metasploit details file not found, querying Metasploit API"
            )
            rpc_client = MsfRpcClient()
            rpc_client.create_metasploit_config(
                details_db_filename, only_allowed_modules
            )

        # Load the config
        cls.data = cls._load_data_from_file(details_db_filename)

        # Store the data in internal dictionaries
        cls.names = {}
        cls.modules = {}

        # Ban certain entries
        for entry in cls.broken_modules:
            try:
                logger.debug('Removing MSF details for %s', entry)
                cls.data.pop(entry)
            except KeyError as error:
                logger.debug('Did not find %s in details', entry)
                logger.debug(error)

        # Create a lookup table for CVEs
        cves_temp = defaultdict(list)
        cls.name_to_cvelist = defaultdict(list)

        # Create a lookup table
        for fullname, info in cls.data.items():

            # Obtain the metasploit name, e.g. "Dynamic key XOR Encoder"
            name = cls.sanitize(info.get('name', ''))

            # Populate a mapping
            cls.modules[fullname] = name
            cls.names[name] = fullname

            # Store CVE information
            cves = info.get('cves', [])
            for cve in cves:
                cve_id = f'CVE-{cve}'
                cves_temp[cve_id].append(fullname)
                cls.name_to_cvelist[name].append(cve_id)

        # Convert to a regular dictionary
        cls.cves = dict(cves_temp)

    @classmethod
    def _load_data_from_file(cls, dbfile: str) -> List:
        """Load the database from a JSON formatted file
        Arguments:
            dbfile (str): name of the JSON file
        Returns:
            list: Metasploit details as a JSON object
        """
        with open(dbfile, 'rb') as in_fp:
            return json.load(in_fp)

    @classmethod
    def get_name_by_module(cls, module_name: str) -> str:
        """Given the fullname, get the human readable name
        e.g.
        In: 'exploit/windows/smb/ms17_010_eternalblue'
        Out: 'MS17-010 EternalBlue SMB Remote Windows Kernel Pool Corruption'
        Arguments:
            module_name (str): module name (fullname)
        Returns:
            str: human-readable Metasploit name
        """
        # Support lazy loading of the data
        if cls.data is None:
            cls.load_data()

        name = cls.modules.get(module_name, None)
        logger.debug('get_name_by_module(%s) = %s', module_name, name)

        return name

    @classmethod
    def get_module_by_name(cls, name: str) -> str:
        """Given the human readable name, get the fullname
        e.g.
        In: 'MS17-010 EternalBlue SMB Remote Windows Kernel Pool Corruption'
        Out: 'exploit/windows/smb/ms17_010_eternalblue'
        Arguments:
            name (str): human-readable Metasploit name
        Returns:
            str: module name (fullname)
        """
        # Support lazy loading of the data
        if cls.data is None:
            cls.load_data()

        module_name = 'Unknown'
        if name:
            sanitized_name = cls.sanitize(name)
            logger.debug('sanitized name = "%s"', sanitized_name)
            module_name = cls.names.get(sanitized_name, 'Unknown')

        logger.debug('get_module_by_name(%s) = %s', name, module_name)
        return module_name

    @classmethod
    def get_names_by_cve_number(cls, cve_number: str) -> List[str]:
        """Get a list of names associated with a CVE
        Arguments:
            cve_number (str): CVE number, e.g. CVE-2017-0143
        Returns:
            List[str]: List of related module names, e.g.
            ['DOUBLEPULSAR Payload Execution and Neutralization',
            'MS17-010 EternalBlue SMB Remote Windows Kernel Pool Corruption',
            ...
            'MS17-010 SMB RCE Detection']
        """

        module_list = cls.get_modules_by_cve_number(cve_number)
        name_list = [cls.get_name_by_module(module) for module in module_list]
        return name_list

    @classmethod
    def get_related_modules_by_module(cls, module: str) -> Set[str]:
        """Get a list of all related modules
        e.g.
        In: 'exploit/windows/smb/ms17_010_eternalblue
        Out:
        {'exploit/windows/smb/ms17_010_eternalblue',
         'exploit/windows/smb/ms17_010_psexec'}
        Arguments:
            module (str): module name (fullname)
        Returns:
            Set[str]: related module names
        """
        related_modules = set()
        info = cls.get_info_by_module(module)
        if info:
            related_modules = cls.get_related_modules_by_name(info.name)

        return related_modules

    @classmethod
    def get_related_modules_by_name(cls, name: str) -> Set[str]:
        '''Get a list of all module names related to a name
        e.g.
        In: 'MS17-010 EternalBlue SMB Remote Windows Kernel Pool Corruption
        Out: ['exploit/windows/smb/ms17_010_eternalblue',
            'exploit/windows/smb/ms17_010_psexec']
        Arguments:
            name (str): human-readable Metasploit name
        Returns:
            List[str]: List of related module names
        '''
        related_modules = set()
        cve_list = cls.get_cvelist_by_name(name)
        for item in cve_list:
            for related_module in cls.get_modules_by_cve_number(item):
                related_modules.add(related_module)

        return related_modules

    @classmethod
    def get_modules_by_cve_number(cls, cve_number: str) -> List[str]:
        '''Get a list of all module names related to a CVE
        e.g.:
        In: 'CVE-2017-0143'
        Out: ['exploit/windows/smb/doublepulsar_rce',
            'exploit/windows/smb/ms17_010_eternalblue',
            'exploit/windows/smb/ms17_010_eternalblue_win8',
            'exploit/windows/smb/ms17_010_psexec',
            'auxiliary/admin/smb/ms17_010_command',
            'auxiliary/scanner/smb/smb_ms17_010']
        Arguments:
            cve_number (str): CVE number
        Returns:
            List[str]: List of related module names
        '''
        # Support lazy loading of the data
        if cls.data is None:
            cls.load_data()

        module_name_list = []
        try:
            module_name_list = cls.cves[cve_number.upper()]
        except KeyError as error:
            logger.debug(
                'get_modules_by_cve_number(%s) found no results', cve_number
            )
            logger.debug(error)

        logger.debug(
            'cve_number: %s, module_name_list: %s',
            cve_number,
            module_name_list,
        )

        return module_name_list

    @classmethod
    def get_options_by_module(cls, module_name: str) -> Dict[str, str]:
        """Get options by fullname
        e.g.
        In: 'exploit/windows/smb/ms17_010_eternalblue'
        Out: {'RHOSTS': '', 'RPORT': 445}
        Arguments:
            module_name (str): the fullname
        Returns:
            Dict[str, str]: option as name, value pair
        """
        options = None

        # Support lazy loading of the data
        if cls.data is None:
            cls.load_data()

        try:
            options = cls.data.get(module_name, {}).get('options', {})
        except KeyError as error:
            logger.debug(
                'Error: get_options_by_module(%s) found no results',
                module_name,
            )
            logger.debug(error)

        logger.debug('get_options_by_module(%s) =  %s', module_name, options)
        return options

    @classmethod
    def get_info_by_module(cls, module_name: str) -> MetasploitInfo:
        """Get information for a module
        e.g.
        In: 'exploit/windows/smb/ms17_010_eternalblue'
        Arguments:
            module_name (str): the fullname
        Returns:
            MetasploitInfo: metasploit information
        """
        info = None

        # Support lazy loading of the data
        if cls.data is None:
            cls.load_data()

        try:
            module_details = cls.data.get(module_name, {})
            info = MetasploitInfo(
                module=module_name,
                name=module_details.get('name', ''),
                rank=module_details.get('rank', ''),
                arch=module_details.get('arch', ''),
                module_type=module_details.get('type', ''),
                description=module_details.get('description', ''),
                targets=module_details.get('targets', ''),
            )
        except KeyError as error:
            logger.debug(
                'Warning: get_info_by_module(%s) found no results', module_name
            )
            logger.debug(error)

        logger.debug('get_info_by_module(%s): info=%s', module_name, info)

        return info

    @classmethod
    def get_options_by_name(cls, name: str) -> Dict[str, str]:
        """Get options by human-readable name
        e.g.
        In: 'MS17-010 EternalBlue SMB Remote Windows Kernel Pool Corruption'
        Out: {'RHOSTS': '', 'RPORT': 445}
        Arguments:
            name (str): human-readable Metasploit name
        Returns:
            dict: option as name, value pair
        """
        module_name = cls.get_module_by_name(name)
        return cls.get_options_by_module(module_name)

    @classmethod
    def get_related_names_by_name(cls, name: str) -> Set[str]:
        """Given a metasploit name, return all related names
        e.g.
        In: 'MS17-010 EternalBlue SMB Remote Windows Kernel Pool Corruption'
        Out:
        {
        'MS17-010 EternalBlue SMB Remote Windows Kernel Pool Corruption',
        'MS17-010 EternalRomance/EternalSynergy/EternalChampion...'
        }
        Arguments:
            name (str): Human-readable Metasploit name

        Returns:
            Set[str]: related names
        """
        related_names = set()
        cve_list = cls.get_cvelist_by_name(name)
        for item in cve_list:
            for related_name in cls.get_names_by_cve_number(item):
                related_names.add(related_name)

        return related_names

    @classmethod
    def get_related_names_by_cve(cls, cve: str) -> Set[str]:
        """Given a cve name, return all related names
        Arguments:
            cve (str): CVE, e.g. CVE-2017-0143
        Returns:
            Set[str]: related names e.g.
            {
            'MS17-010 EternalBlue SMB Remote Windows Kernel Pool Corruption',
            'MS17-010 EternalRomance/EternalSynergy/EternalChampion...'
            }
        """
        related_names = set()

        for name in cls.get_names_by_cve_number(cve):
            related_names.add(name)
        return related_names

    @classmethod
    def get_cvelist_by_name(cls, name: str) -> List[str]:
        """Get a list of cve numbers by name
        Arguments:
            name (str): human-readable Metasploit name
        Returns:
            List[str]: list of CVE numbers
        """
        # Support lazy loading of the data
        if cls.data is None:
            cls.load_data()

        cvelist = cls.name_to_cvelist.get(name, [])

        logger.debug('get_cvelist_by_name(%s) = %s', name, cvelist)

        return cvelist

    @classmethod
    def clean(cls):
        '''Remove the existing configuration'''
        for filename in [METASPLOIT_CONFIG_FILENAME]:
            full_filename = cls._get_db_filename(filename)
            if os.path.isfile(full_filename):
                logger.info('Removing file %s', full_filename)
                os.remove(full_filename)
                cls.load_broken_modules()
                cls.load_details(only_allowed_modules=False)
            else:
                logger.info('File %s does not exist', full_filename)


def main():
    """TODO: Command line utility"""


if __name__ == '__main__':
    main()
