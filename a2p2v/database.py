#!/usr/bin/env python3
#
#  Copyright (C) 2018-2021 Toshiba Corporation and Peraton Labs, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

""" This module provides database access convenience
    functions for use by other modules.  Additionally
    provides import of capabilities from an xml file.
"""

import logging
import os
import sqlite3
import xml.etree.ElementTree as ET
from typing import Dict

from .config import get_config_dir
from .types import Capability

# The name of the database file
DATABASE_FILENAME = 'a2p2v.db'

CAPABILITY_INSERT_STMT = (
    "INSERT INTO capability VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?)"
)
PAP_INSERT_STMT = 'INSERT INTO pap VALUES(?, ?, ?, ?, ?, ?)'

CAPABILITY_QUERY_STMT = "SELECT * FROM capability"

PAP_QUERY_STMT = (
    "SELECT pap_host, pap_type, pap_key, pap_value "
    "FROM pap WHERE capability_id = :capability_id "
    "AND pap_class = :pap_class"
)

logger = logging.getLogger(__name__)


def get_database_filename() -> str:
    """Get the full path and name of the configuration file
    On Linux, this is $HOME/.config/a2p2v/a2p2v.db
    Returns:
        str: full path and name of the database file
    """
    config_dir = get_config_dir()
    return os.path.join(config_dir, DATABASE_FILENAME)


def import_db_from_file(capabilities_xml_filename: str):
    """Using a capabilities definition XML file, populate a SQLite DB.
    First, create the tables if they do not already exist.
    Then, walk through each capability definition, populating the
    capability and pre-condition, action, post-condition (pap) tables.
    Arguments:
        capabilities_xml_filename (str): name of the definitions file
    """

    db_filename: str = get_database_filename()

    # Check if the db already exists
    if os.path.isfile(db_filename):
        user_response = input(
            'Warning: database file already exists! Remove and reload (n/Y)?: '
        ).strip()
        if user_response not in ('y', 'Y', ''):
            return
        os.remove(db_filename)
        logger.debug('%s removed.', db_filename)

    conn = sqlite3.connect(db_filename)
    cursor = conn.cursor()

    # Create the Database tables
    _create_tables(cursor)

    # Parse file
    tree = ET.parse(capabilities_xml_filename)
    root = tree.getroot()
    for icapability in root.findall('capability'):
        capability_id = icapability.attrib['id']
        # If this is a derived capability, inherit from parent capability
        parent = None
        if '.' in capability_id:
            parent = _extract_parent_capability(capability_id, cursor)

        _store_capability(capability_id, conn, cursor, icapability, parent)
        _store_preconditions(capability_id, conn, cursor, icapability)
        _store_actions(capability_id, conn, cursor, icapability)
        _store_postconditions(capability_id, conn, cursor, icapability)

    conn.close()


def _store_capability(capability_id, conn, cursor, icapability, parent):
    capability_details = _parse_capability_fields(icapability, parent)
    capability_parameters = (
        capability_id,
        capability_details.title,
        capability_details.capability_class,
        capability_details.subclass,
        capability_details.severity,
        capability_details.cvss,
        capability_details.rank,
        capability_details.solution,
        capability_details.cves,
    )
    _execute_and_commit(
        CAPABILITY_INSERT_STMT, capability_parameters, cursor, conn
    )


def _parse_capability_fields(icapability, parent) -> Capability:
    # Extract capability information
    title = _parse_capability_title(icapability)
    cap_class = _parse_capability_class(icapability, parent)
    subclass = _parse_capability_subclass(icapability)
    severity = _extract_capability_severity(icapability, parent)
    cvss = _extract_capability_cvss(icapability, parent)
    rank = _extract_capability_rank(icapability, parent)
    solution = _extract_capability_solution(icapability, parent)
    cves = _extract_capability_cves(icapability)

    return Capability(
        None,
        title,
        cap_class,
        subclass,
        severity,
        cves,
        cvss,
        None,
        None,
        None,
        rank,
        solution,
    )


def _extract_capability_cves(icapability):
    if 'cve' in icapability.attrib:
        capability_cves = icapability.attrib['cve'].lower()
    else:
        capability_cves = ""
    return capability_cves


def _extract_capability_solution(icapability, parent_capability):
    capability_id = icapability.attrib['id']
    if 'solution' in icapability.attrib:
        capability_solution = icapability.attrib['solution']
    elif parent_capability is not None:
        capability_solution = parent_capability.solution
    else:
        logger.warning(
            "Capability %s does not specify solution.  Assuming ''",
            capability_id,
        )
        capability_solution = ""
    return capability_solution


def _extract_capability_rank(icapability, parent_capability):
    capability_id = icapability.attrib['id']

    if 'rank' in icapability.attrib:
        capability_rank = icapability.attrib['rank']
    elif parent_capability is not None:
        capability_rank = parent_capability.rank
    else:
        logger.warning(
            "Capability %s does not specify rank.  Assuming 'normal'",
            capability_id,
        )
        capability_rank = 'normal'  # Normal
    return capability_rank


def _extract_capability_cvss(icapability, parent_capability):
    capability_id = icapability.attrib['id']
    capability_cvss = ""
    if 'cvss' in icapability.attrib:
        capability_cvss = icapability.attrib['cvss']
    elif parent_capability is not None:
        capability_cvss = parent_capability.cvss
    elif icapability.attrib['class'] not in ['template', 'service']:
        logger.warning(
            "Capability %s does not specify cvss.  Leaving blank",
            capability_id,
        )
    return capability_cvss


def _extract_capability_severity(icapability, parent_capability):
    capability_id = icapability.attrib['id']
    if 'severity' in icapability.attrib:
        capability_severity = icapability.attrib['severity']
    elif parent_capability is not None:
        capability_severity = parent_capability.severity
    else:
        logger.warning(
            "Capability %s does not specify severity.  Assuming 'none'",
            capability_id,
        )
        capability_severity = 'none'
    return capability_severity


def _parse_capability_subclass(icapability):
    capability_id = icapability.attrib['id']
    if 'subclass' in icapability.attrib:
        capability_subclass = icapability.attrib['subclass'].lower()
    else:
        capability_subclass = capability_id
    return capability_subclass


def _extract_parent_capability(capability_id, cursor):
    parent_capability_id = capability_id.split('.')[0]
    title, cap_class, subclass, severity, cvss, rank, solution, cves = (
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
    )
    cursor.execute(
        f"SELECT title, class, subclass, severity, cvss, rank, solution, cves "
        f"FROM capability "
        f"WHERE capability_id == '{parent_capability_id}'; "
    )
    rows = cursor.fetchall()
    if rows:
        result = rows[0]
        (
            title,
            cap_class,
            subclass,
            severity,
            cvss,
            rank,
            solution,
            cves,
        ) = result
    else:
        logger.error(
            "Parent %s for derived capability %s not found.",
            parent_capability_id,
            capability_id,
        )
    return Capability(
        capability_id,
        title,
        cap_class,
        subclass,
        severity,
        cves,
        cvss,
        None,
        None,
        None,
        rank,
        solution,
    )


def _parse_capability_class(icapability, parent_capability):
    capability_id = icapability.attrib['id']
    if 'class' in icapability.attrib:
        capability_class = icapability.attrib['class'].lower()
    elif parent_capability is not None:
        capability_class = parent_capability.capability_class
    else:
        logger.warning(
            "Capability %s does not specify class.  Assuming service",
            capability_id,
        )
        capability_class = 'service'
    return capability_class


def _parse_capability_title(icapability):
    capability_id = icapability.attrib['id']
    if 'title' in icapability.attrib:
        capability_title = icapability.attrib['title']
    else:
        capability_title = capability_id
    return capability_title


def _store_actions(capability_id, conn, cursor, icapability):
    actions = icapability.findall('actions/action')
    for action in actions:
        ac_type = action.attrib['type']
        ac_key = action.attrib['key']
        ac_value = action.attrib['value']

        action_parameters = (
            capability_id,
            'action',
            '',
            ac_type,
            ac_key,
            ac_value,
        )
        _execute_and_commit(PAP_INSERT_STMT, action_parameters, cursor, conn)


def _store_postconditions(capability_id, conn, cursor, icapability):
    postconditions = icapability.findall('postconditions/condition')
    for postcondition in postconditions:
        pc_type = postcondition.attrib['type']
        pc_key = postcondition.attrib['key']
        pc_value = postcondition.attrib['value']

        postcondition_parameters = (
            capability_id,
            'postcondition',
            '',
            pc_type,
            pc_key,
            pc_value,
        )
        _execute_and_commit(
            PAP_INSERT_STMT, postcondition_parameters, cursor, conn
        )


def _store_preconditions(capability_id, conn, cursor, icapability):
    preconditions = icapability.findall('preconditions/condition')
    for precondition in preconditions:
        pc_host = precondition.attrib['host']
        pc_type = precondition.attrib['type']
        pc_key = precondition.attrib['key']
        pc_value = precondition.attrib['value']

        precondition_parameters = (
            capability_id,
            'precondition',
            pc_host,
            pc_type,
            pc_key,
            pc_value,
        )
        _execute_and_commit(
            PAP_INSERT_STMT, precondition_parameters, cursor, conn
        )


def _create_tables(cursor):
    # Create database tables
    cursor.execute(
        "CREATE TABLE capability ("
        "    capability_id VARCHAR(128) NOT NULL,"
        "    title TEXT,"
        "    class VARCHAR(12) NOT NULL,"
        "    subclass VARCHAR(128),"
        "    severity VARCHAR(8),"
        "    cvss VARCHAR(128),"
        "    rank VARCHAR(10),"
        "    solution TEXT,"
        "    cves TEXT,"
        "    CONSTRAINT pk_capability PRIMARY KEY(capability_id)"
        ");"
    )
    cursor.execute(
        "CREATE TABLE pap ("
        "    capability_id VARCHAR(128) NOT NULL,"
        "    pap_class VARCHAR(15) NOT NULL,"
        "    pap_host VARCHAR(128),"
        "    pap_type VARCHAR(255) NOT NULL,"
        "    pap_key VARCHAR(255) NOT NULL,"
        "    pap_value TEXT NOT NULL,"
        "    CONSTRAINT capabilitypap FOREIGN KEY(capability_id)"
        "    REFERENCES capability(capability_id)"
        "    ON UPDATE NO ACTION"
        "    ON DELETE NO ACTION,"
        "    CONSTRAINT pk_pap"
        "    PRIMARY KEY(capability_id, pap_class,"
        "        pap_host, pap_type, pap_key, pap_value)"
        ");"
    )


def _execute_and_commit(statement: str, parameters, cursor, conn):
    logger.debug('%s %s', statement[: statement.find('(')], parameters)
    cursor.execute(statement, parameters)
    conn.commit()


class Database:
    """Provides methods to query and update the capabilities database"""

    def __init__(self):
        self.conn = None
        self._connect()

    def ready(self):
        '''Return True if connected to the database'''
        return self.conn is not None

    def _connect(self):
        """Connects to the sqlite3 database"""
        database_file = get_database_filename()
        if not os.path.isfile(database_file):
            logger.error('No capabilities database found')
            logger.error(
                'To import a database from xml: a2p2v --importdb <filename>.xml'
            )
        else:
            self.conn = sqlite3.connect(database_file)

    def query(self, statement: str, parameters: Dict = None):
        """Given a database query and directive to commit, executes the query against
           the database and returns the result
        Arguments:
            statement (string): The query to perform
            parameters (Dict): Parameters to use
        Returns:
            rows (list of dictionaries): The results of the database query.
        """
        logger.debug(
            'query(): statement: %s, parameters: %s', statement, parameters
        )
        cursor = self.conn.cursor()
        if parameters is None:
            parameters = {}
        try:
            cursor.execute(statement, parameters)
        except ValueError as value_error:
            logger.exception(value_error)
            logger.debug("Exception with: %s", statement)
        except sqlite3.Error as exception:
            logger.exception(exception)
            logger.debug("Exception with: %s", statement)

        rows = cursor.fetchall()

        cursor.close()
        return rows

    def _execute(
        self, statement: str, parameters: tuple = None, commit: bool = True
    ):
        cursor = self.conn.cursor()

        logger.debug('%s %s', statement[: statement.find('(')], parameters)
        cursor.execute(statement, parameters)
        if commit:
            self.conn.commit()
        cursor.close()

    def insert_capability(self, capability: Capability):
        """Insert a capability definition into the database.
        Arguments:
            capability(Capability): the capability
        """
        parameters = (
            capability.capability_id,
            capability.title,
            capability.capability_class,
            capability.subclass,
            capability.severity,
            capability.cvss,
            capability.rank,
            capability.solution,
            capability.cves,
        )
        self._execute(CAPABILITY_INSERT_STMT, parameters, commit=True)

    def _insert_pap(self, capability_id: str, values: Dict, pap_class: str):
        parameters = (
            capability_id,
            pap_class,
            values.get('host', ''),
            values.get('type', ''),
            values.get('key', ''),
            values.get('value', ''),
        )
        self._execute(PAP_INSERT_STMT, parameters, commit=True)

    def insert_precondition(self, capability_id: str, precondition: Dict):
        '''Insert a precondition into the capabilities database
        Arguments:
            capability_id (str): capability id
            precondition (Dict): dictionary of preconditions
        '''
        self._insert_pap(capability_id, precondition, pap_class='precondition')

    def insert_action(self, capability_id: str, actions: Dict):
        '''Insert an action into the capabilities database
        Arguments:
            capability_id (str): capability id
            actions (Dict): dictionary of actions
        '''
        self._insert_pap(capability_id, actions, pap_class='action')

    def insert_postcondition(self, capability_id: str, postcondition: Dict):
        '''Insert a postcondition into the capabilities database
        Arguments:
            capability_id (str): capability id
            postcondition (Dict): dictionary of postconditions
        '''
        self._insert_pap(
            capability_id, postcondition, pap_class='postcondition'
        )

    def _get_pap(self, capability_id: str, pap_class: str):
        parameters = {
            'capability_id': capability_id,
            'pap_class': pap_class,
        }
        return self.query(PAP_QUERY_STMT, parameters)

    def get_capabilities(self):
        '''Get list of capabilities'''
        return self.query(CAPABILITY_QUERY_STMT)

    def get_preconditions(self, capability_id: str):
        '''Get list of preconditions
        Arguments:
            capability_id (str): capability id
        '''
        return self._get_pap(capability_id, 'precondition')

    def get_actions(self, capability_id: str):
        '''Get list of actions
        Arguments:
            capability_id (str): capability id
        '''
        return self._get_pap(capability_id, 'action')

    def get_postconditions(self, capability_id: str):
        '''Get list of postconditions
        Arguments:
            capability_id (str): capability id
        '''
        return self._get_pap(capability_id, 'postcondition')
