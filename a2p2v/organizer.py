#!/usr/bin/env python3
#
#  Copyright (C) 2018-2021 Toshiba Corporation and Perspecta Labs, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

""" This module interacts with the executor module to perform the actions
    in a specified attack tree.  The organizer instructs the executor to
    send commands to Metasploit.  Depending on the response, the organizer
    will react accordingly.

    The organizer also creates a detailed report, showing the status of
    each attack as well as evidence showing the interaction with Metasploit.
"""

import collections
import logging
import os
import re
import string
import subprocess
import time

from .common import get_file_timestamp, get_report_timestamp
from .executor import Executor, Simulator
from .planner import Planner
from .visualizer import Visualizer

logger = logging.getLogger(__name__)


class Organizer:
    """The Organizer issues commands to the Executor.
    Given an attack tree and user selection, the
    organizer issues commands to the Metasploit API
    via the executor.  The executor returns the
    responses of the commands, and the organizer
    reacts accordingly.
    """

    def __init__(
        self,
        planner: Planner,
        mode: str,
        minimum_score: float,
        visualizations: bool = False,
        execute: bool = False,
        post_execute_script: str = None,
        lhost: str = None,
        sleep_seconds: float = 1.0
    ):
        '''Create a new organizer given an attack tree
        Arguments:
            planner(Planner): instance of a a2p2v planner
            mode(str): single, system or black
            minimum_score (float): minimum score of trees to consider
            visualizations (bool): if True, enable visualizations
            execute (bool): if True, run the attacks, otherwise simulate
            post_execute_script (str): script to run after execution
            lhost(str): lhost to use with Metasploit
        '''
        self._sleep_seconds = sleep_seconds

        # Regex patterns for matching responses from Metasploit API
        self.is_done_pattern = re.compile(
            r'Command shell session|Meterpreter session|'
            r'Exploit completed|execution completed|Route added'
        )
        self.success_pattern = re.compile(
            r"(Backgrounding session|Starting interaction with|"
            r"already interactive|Succeeded)"
        )
        self.failure_pattern = re.compile(
            r'RuntimeError|Invalid session identifier|'
            r'Meterpreter session \d+ closed|'
            r'Failed|failed|no session was created'
        )
        self.session_success_pattern = re.compile(
            r'Meterpreter session \d+ opened|Command shell session \d+ opened'
        )
        self.command_shell_success_pattern = re.compile(
            r'Command shell session \d+ opened'
        )
        self.meterpreter_shell_success_pattern = re.compile(
            r'Meterpreter shell session \d+ opened'
        )

        self._post_execute_script = post_execute_script
        # Create deposits for results
        self._targets = set()
        self._score = None
        self._goals = None
        self._details = {}
        self._evidence = []

        self._lhost = lhost
        self.attack_trees = planner.attack_trees
        self.execute_enabled = execute
        self._last_password = None  # Keep track of last password used for sudo
        self._current_session = None  # Keep track of last opened session ID
        # Execution mode:
        # - 'single' for single host
        # - 'system' for system
        # - 'black' for blackbox
        self._exec_mode = mode
        self._scan_ports = "1-1024"
        self._min_score = minimum_score
        self._visualizations = visualizations
        if self._visualizations:
            self._visualizer = Visualizer(
                planner.host_capabilities, planner.network_graph
            )

        # If we are in system mode and visualizations are enabled
        # and the 'loadtrees' option wasn't utilized
        # enabled network graph and composite attack tree visualizations
        if (
            self._exec_mode == 'system'
            and self._visualizations
            and hasattr(planner, 'host_capabilities')
        ):
            logger.info("Displaying internal network representation")
            self._visualizer.show_network_vis()
            logger.info("Displaying combined attack tree representation")
            self._visualizer.show_attack_trees_vis(planner)

        if self.execute_enabled:
            self._executor = Executor()
        else:
            self._executor = Simulator()

        # If we have trouble starting the executor, switch to simulator
        if not self._init_executor():
            self.execute_enabled = False
            self._executor = Simulator()

        if self.execute_enabled:
            logger.debug("*** Organizer will perform LIVE execution ***")
        else:
            logger.debug("*** Organizer will perform SIMULATED execution ***")

        # This allows you to reference by: self._issues[host][issue]
        self._issues = collections.defaultdict(
            lambda: collections.defaultdict(collections.defaultdict)
        )

    def sleep(self, num_seconds=None):
        """Sleep, but only for real execution (not simulated)
        Arguments:
            num_seconds(int): number of seconds to sleep
        """
        if num_seconds is None:
            num_seconds = self._sleep_seconds

        if self.execute_enabled:
            time.sleep(num_seconds)

    def _init_executor(self):
        if not self._executor.valid:
            return False
        self._skip_banner()
        self._set_metasploit_globals()
        return True

    def _skip_banner(self, max_tries=1000):
        tries = 0
        while 'prompt' not in self._executor.read() and tries < max_tries:
            tries += 1

    def _set_metasploit_globals(self):
        self._log_line('```\n\n')
        self._send_command('set EXITFUNC process')
        self._send_command('set LHOST {}'.format(self._lhost))
        self._log_line('\n\n```\n\n')

    def create_report(self, planning: bool):
        """Write a report to an output file
        Arguments:
            planning(bool): True if planning is enabled, False if single-host
        """
        if not os.path.exists('reports'):
            os.makedirs('reports')

        filename_timestamp = get_file_timestamp()

        report_filename = "reports/report_{}.md".format(filename_timestamp)
        with open(report_filename, 'w') as report:
            report.write(
                '# Report generated on {}\n\n'.format(get_report_timestamp())
            )

            self._write_report_summary_section(planning, report)
            self._write_report_targets_section(planning, report)
            self._write_report_capability_details_sections(report)
            self._write_report_plugins_section()
            self._write_report_evidence_section(report)

        logger.info("Report written to: %s", report_filename)
        print(f"Report written to: {report_filename}")

    def _write_report_plugins_section(self):
        pass
        # report.write('The following plugins were enabled:\n\n')
        # report.write('- TODO\n\n')

    def _write_report_evidence_section(self, report):
        report.write('## Execution Evidence\n\n')
        report.writelines(self._evidence)

    def _write_report_capability_details_sections(self, report):
        report.write('## Details of Utilized Capabilities:\n\n')
        for issue_detail in sorted(self._details.keys()):
            self._write_report_issue_detail(issue_detail, report)
        report.write('\n\n')
        report.write('---\n\n')

    def _write_report_targets_section(self, planning, report):
        if not planning:
            report.write('## The following targets were provided:\n\n')

            for target in sorted(self._targets):
                report.write('- {}\n'.format(target))
            report.write('\n---\n')
        report.write('\n')

    def _write_report_summary_section(self, planning, report):
        if self.execute_enabled:
            report.write('## Summary of Execution\n\n')
        else:
            report.write('## Summary of Simulated Execution\n\n')
        report.write('---\n\n')
        if planning:
            report.write('    Attack Tree Score: {}\n'.format(self._score))
            report.write(
                '    Goals Reached: {}\n'.format(','.join(self._goals))
            )
            report.write('---\n\n')
        report.write(
            '{:11}|{:20}|{:20}|{:}|\n'.format(
                'Sensitivity', 'Host', 'Success', 'Capability'
            )
        )
        report.write(
            ':'
            + '-' * 11
            + '|:'
            + '-' * 20
            + ':|:'
            + '-' * 20
            + ':|:'
            + '-' * 100
            + '|\n'
        )
        for host in sorted(self._issues.keys()):
            for issue, value in self._issues[host].items():
                success = str(value['success'])
                if value['sensitive']:
                    report.write("{:11}|".format(value['sensitive']))
                else:
                    report.write("{:11}|".format('NONE'))
                report.write('{:20}|{:20}|{}\n'.format(host, success, issue))
        report.write('\n')
        report.write('---\n\n')

    def _write_report_issue_detail(self, issue_detail, report):
        # report.write('-'*140 + '\n')
        report.write('### {}\n\n'.format(issue_detail))
        report.write(
            '- Exploit Class: {}\n'.format(
                self._details[issue_detail]['expClass']
            )
        )
        report.write(
            '- Severity: {}\n'.format(self._details[issue_detail]['severity'])
        )
        report.write(
            '- Rank: {}\n'.format(self._details[issue_detail]['rank'])
        )
        cves = self._details[issue_detail]['cves'].split(',')
        if cves[0] != '':
            report.write("- CVEs\n")
            for cve in self._details[issue_detail]['cves'].split(','):
                report.write(
                    f"\t- [{cve}]"
                    f"(https://nvd.nist.gov/vuln/detail/{cve})\n"
                )
        solution = self._details[issue_detail]['solution']
        if solution:
            report.write(
                '- Solution: {}\n\n'.format(
                    self._details[issue_detail]['solution']
                )
            )
        # report.write('-'*140 + '\n')

    def _run_post_execution_script(self):
        if not os.path.isfile(self._post_execute_script):
            logger.error(
                'Could not find post execute script: %s',
                self._post_execute_script,
            )
            return

        logger.info(
            'Running post execute script: %s.', self._post_execute_script
        )
        subprocess_output = subprocess.check_output(self._post_execute_script)
        logger.info('Sub_process output: %s.', subprocess_output)

    def _show_attack_trees(self, trees):
        print('\n')

        if 'goals' not in self.attack_trees[0].keys():
            self._exec_mode = 'single'

        if self._exec_mode == 'single':
            print('{:5}|{:5}|{:}'.format('TREE#', 'SCORE', 'CAPABILITY'))
            print('-' * 5 + '|' + '-' * 5 + '|' + '-' * 50)
        else:
            print(
                '{:5}|{:5}|{:35}|{:50}|{:}'.format(
                    'TREE#',
                    'SCORE',
                    'HOPS',
                    'FINAL CAPABILITY OPTIONS',
                    'GOALS',
                )
            )
            print(
                '-' * 5
                + '|'
                + '-' * 5
                + '|'
                + '-' * 35
                + '|'
                + '-' * 50
                + '|'
                + '-' * 15
            )
        filtered_attack_trees = [
            attack_tree
            for attack_tree in trees
            if not self._min_score
            or (
                self._min_score
                and attack_tree.get('score', {}).get('combined', 0.0)
                >= float(self._min_score)
            )
        ]
        final_capability = 'N/A'

        for idx, attack_tree in enumerate(filtered_attack_trees):
            score = attack_tree['score']['combined']
            if not self._min_score or (
                self._min_score and score >= float(self._min_score)
            ):
                hops = []
                for hop in attack_tree['hops']:
                    hop_options = len(hop['options'])
                    hops.append('{}({})'.format(hop['node'], hop_options))
                last_hop = attack_tree['hops'][-1]
                printable_idx = idx
                for option in last_hop['options']:
                    final_capability = (
                        option['actions'][-1]['value']
                        .split(' ')[0]
                        .replace('module=', '')
                    )
                    if self._exec_mode == 'single':
                        print(
                            '{:5}|{:5}|{:}'.format(
                                printable_idx, score, final_capability
                            )
                        )
                    else:
                        goals = attack_tree['goals']
                        print(
                            '{:5}|{:5}|{:35}|{:50}|{:}'.format(
                                printable_idx,
                                score,
                                '>'.join(hops),
                                final_capability,
                                ' '.join(goals),
                            )
                        )
                    printable_idx = score = hops = ''
                if idx < len(filtered_attack_trees) - 1:
                    if self._exec_mode == 'single':
                        print('-' * 5 + '|' + '-' * 5 + '|' + '-' * 50)
                    else:
                        print(
                            '-' * 5
                            + '|'
                            + '-' * 5
                            + '|'
                            + '-' * 35
                            + '|'
                            + '-' * 50
                            + '|'
                            + '-' * 15
                        )
        if self._exec_mode == 'single':
            print('-' * 64)
        else:
            print('-' * 114)

    def _do_hop(self, hop, node):
        hop_successful = False
        severity = hop['severity'].title()
        solution = hop['solution']
        capability_name = hop['capability']
        rank = hop['rank'].title()
        cves = hop.get('cves', '')
        if 'sensitivity' in hop.keys():
            sensitivity = hop['sensitivity']['type'].upper()
        else:
            sensitivity = {}

        action_list = hop['actions']

        for action_num, action in enumerate(action_list):
            action_type = action['type']
            action_value = action['value']
            action_key = action['key']

            if action_type == 'manual':
                full_name = "Manual action: {}".format(action_value)
                module = action_value
                hop_successful = True
                exp_class = None
            elif action_type == 'shell_command':
                full_name = "Shell Command: {}".format(action_key)
                module = action_value
                if '$username' in module or '$password' in module:
                    hop_successful = False
                else:
                    hop_successful = True
                exp_class = None

            elif action_type == 'metasploit':
                # Parse the metasploit module name and values from the string
                results = self.parse_values(action_value)
                logger.debug('results = %s', results)
                exp_class = (
                    action_key.replace('parameters', 'Auxiliary Module')
                    .replace('_', ' ')
                    .capitalize()
                )
                exp_class = f'Metasploit ({exp_class})'

                if 'CMD' in results.keys():
                    full_name = "Metasploit Post Exploitation Module"
                    record_detail = False
                else:
                    record_detail = True
                    # Get the metasploit module name
                    module = results['MODULE']
                    full_name = "Metasploit: {}".format(capability_name)

                logger.info('Attempting: %s on node: %s', full_name, node)
                # Begin the evidence section of the report
                self._evidence.append('\n### {}\n'.format(node))
                self._evidence.append('### {}\n\n'.format(full_name))
                short_name = ' '.join(full_name.split(' ')[:3]).split('/')[0]
                if self._visualizations and not self._exec_mode == 'single':
                    self._visualizer.graph_advance(
                        node=node, command=short_name
                    )
                self._evidence.append('\n```\n')

                # Execute the atack step
                hop_successful = self.execute(results)
            else:
                logger.error(
                    "Action_num %s: Unknown action type: %s",
                    action_type,
                    action_num,
                )
                return False

            if record_detail:
                self._issues[node][full_name] = {
                    'success': hop_successful,
                    'sensitive': sensitivity,
                }
                self._details[capability_name] = {
                    'severity': severity,
                    'cves': cves,
                    'rank': rank,
                    'solution': solution,
                    'expClass': exp_class,
                }

            # End the evidence section of the report
            self._evidence.append('\n```\n\n')
            logger.debug(
                'issues[%s][%s] = %s, module = %s',
                node,
                full_name,
                hop_successful,
                module,
            )

            if hop_successful:
                logger.info("Successful result on node: %s", node)
                if self._visualizations and self._exec_mode != 'single':
                    self._visualizer.graph_advance(status=10)

            return hop_successful

    # TODO: Include ability to perform more complex selection based on criteria
    def _selection(self, trees=None, criteria=None):
        logger.info("Generating list of successful attack trees")
        if criteria is None:
            criteria = {}
        if not trees:
            trees = self.attack_trees
        # Display the list of attack trees
        self._show_attack_trees(trees)
        # Request the tree from the user
        if self._exec_mode == 'single':
            selected_tree_num = input(
                "Select a capability to execute, 'a' for all, or any other value to skip: "
            )
            if selected_tree_num == 'a':
                return selected_tree_num
        else:
            selected_tree_num = input(
                'Select an attack tree to execute (or any other value to exit): '
            )

        if (
            not selected_tree_num.isnumeric()
            or int(selected_tree_num) > len(trees) - 1
        ):
            selected_tree_num = -1
        else:
            selected_tree_num = int(selected_tree_num)

        return selected_tree_num

    def launch(self, tree_num, targets=None):
        """Run the steps from an attack tree
        Arguments:
            tree_num (int): the number of the attack tree to run
            targets (list): list of targets to attack
        Returns:
            bool: True if successful, False if not
        """
        result = False
        if targets is None:
            targets = []
        logger.debug('Targets = %s', targets)

        if len(self.attack_trees) == 0:
            logger.warning("No attack trees produced")
            return False

        if self._exec_mode == 'single':
            for target in targets:
                self._targets.add(target)
                result |= self._launch_single_target(target)
        elif self._exec_mode == 'black':
            logger.error("Black box mode is not currently supported")
            return False
        else:
            result = self._launch_system_target(tree_num)

        self._executor.stop_all_sessions()
        self._executor.destroy_console()

        # Launch a post execution script if specified
        if self._post_execute_script:
            self._run_post_execution_script()

        return result

    def _launch_system_target(self, tree_num=None):
        logger.debug("Called with: %s", tree_num)

        if tree_num is None:
            tree_num = self._selection(criteria={})

        if tree_num >= 0:
            try:
                attack_tree = self.attack_trees[tree_num]
            except Exception:
                logger.error("Attack Tree #%s does not exist", tree_num)
                return False
            self._score = attack_tree['score']['combined']
            self._goals = attack_tree['goals']
            hop_list = attack_tree['hops']
            if self._visualizations:
                self._visualizer.initialize_visuals()
            for hop in hop_list:
                hop_success = False
                for option in hop['options']:
                    if self._do_hop(option, hop['node']):
                        logger.debug("Hop option Succeeded")
                        hop_success = True
                        break
                    else:
                        logger.debug("Hop option Failed")
                if hop_success is False:
                    logger.debug("All hop options failed, bailing")
                    break
            if self._visualizations:
                self.sleep(5)
                self._visualizer.cleanup()
            return True
        else:
            return False

    def _launch_single_target(self, target):
        logger.info(
            "Launching single host mode execution for target: %s", target
        )
        self._exec_mode = "single"

        target_attack_trees = []
        for attack_tree in self.attack_trees:
            if attack_tree['hops'][0]['node'] == target:
                target_attack_trees.append(attack_tree)

        tree_num = self._selection(trees=target_attack_trees, criteria={})

        if tree_num == 'a':
            attack_trees_to_execute = target_attack_trees
        elif tree_num == -1:
            return False
        else:
            attack_trees_to_execute = [target_attack_trees[tree_num]]

        for attack_tree in attack_trees_to_execute:
            node = attack_tree['hops'][0]['node']
            option = attack_tree['hops'][0]['options'][0]
            self._do_hop(option, node)
            # Cleanup after each step
            self.stop_current_session()

        return True

    def stop_current_session(self):
        '''Use the console to quit the current session if it exists.'''
        if self._current_session:
            logger.debug('Killing session %s', self._current_session)
            self._send_command('quit')
            self._current_session = None

    def execute(self, action):
        '''Executes an action in the metasploit interrupter
        Args:
            action(?): the action to execute
        Returns:
            bool: whether the attack was successful
        '''
        if not self._executor.ready():
            logger.error("Problem with executor instantiation")
            return False

        # Execute a single Meterpreter command (Disabling for now)
        if 'CMD' in action.keys():
            return True

        # Set the Metasploit Module
        module = action['MODULE']
        command = 'use {}'.format(module)

        if not self._send_command(command):
            logger.error("Attempt to use module '%s' failed", module)
            return False

        # Set any Module Options
        for name, value in action.items():
            if name in ['PASSWORD', 'password', 'Password']:
                self._last_password = value
            if name not in ['MODULE']:
                command = 'set {} {}'.format(name, value)
                if not self._send_command(command):
                    logger.warning(
                        "Unable to set module option '%s' to '%s{}'",
                        name,
                        value,
                    )

        # Run the Metasploit Module
        if not self._send_command('run'):
            return False

        return True

    # Send a command to the executor.  Replace variables
    def _send_command(self, command):
        command = command.replace('$session', str(self._current_session))
        command = command.replace('$password', str(self._last_password))
        self._log_line(command)
        self._executor.write(command, delay_time_seconds=self._sleep_seconds)

        return self._do_read()

    def _log_line(self, line):
        self._evidence.append("{}\n".format(line))

    def _do_read(self, max_attempts=60):
        results = None
        attempts = 0
        while results is None and attempts < max_attempts:
            results = self._parse_read_results(self._executor.read())
            self.sleep()
            attempts += 1

        return results

    def _parse_read_results(self, results):
        self._log_results(results)

        busy = results.get('busy', False)
        data = results.get('data', '')

        if data == '' and not busy:
            return True

        # These are generic 'success' messages
        if self.success_pattern.search(data):
            logger.debug("***Found generic success message***")
            return True

        # These are generic 'failure' messages
        if self.failure_pattern.search(data):
            logger.warning("***Found generic failure message***")
            return False

        if re.search(r"Meterpreter session \d+ opened", data):
            logger.debug("***Found Meterpreter session opened!***")
            return self._meterpreter_session_opened(data)

        if re.search(r"Command shell session \d+ opened", data):
            logger.debug("***Found Command shell session opened!***")
            return self._command_shell_opened(data)

        # Trigger for route added
        if re.search("Route added", data):
            logger.debug("***Found Route added!***")
            return self._route_added(data)

        # Detect when autoroute did not find any new routes
        if re.search("Did not find any new subnets", data):
            logger.debug("***No new subnets found, no route added.***")
            return True

        # Detect when a new host is found (ie. when arp scanning)
        if re.search("host found", data):
            logger.debug("***Host Found!***")
            return self._host_found(data)

        # Detect when an open port has been detected (ie. when port scanning)
        if re.search("TCP OPEN", data):
            logger.debug("***Open TCP Port Found!***")
            return self._open_port(data)

        return None

    @classmethod
    def _sanitize(cls, text):
        '''Remove any non-printable characters from a string
        Arguments:
            text (str): the string
        Returns:
            str: sanitized string
        '''
        return ''.join([c for c in text if c in string.printable])

    def _log_results(self, results, show_prompt=True):
        if 'data' not in results.keys() or results['data'] == '':
            return
        if show_prompt and 'prompt' in results.keys():
            line = '{}\n{}'.format(
                self._sanitize(results['data']),
                self._sanitize(results['prompt']),
            )
        else:
            line = '{}\n'.format(self._sanitize(results['data']))
        self._evidence.append(line)

    def _open_port(self, data):
        if self._exec_mode == 'black':
            ports = re.findall(" (.*?):(.*?) - TCP OPEN", data)
            for port in ports:
                self._do_port_detect(port[0], port[1])
        return True

    def _do_port_detect(self, host, port):
        logger.debug('do_port_detect: host=%s, port=%s', host, port)
        return True

    def _route_added(self, data):
        if self._exec_mode == 'black':
            routes = re.findall("Route added to subnet (.*?) from", data)
            for route in routes:
                self._do_pingsweep(route)
        return True

    def _host_found(self, data):
        if self._exec_mode == 'black':
            hosts = re.findall("     (.*?) host found", data)
            for host in hosts:
                self._do_portscan(host)
        return True

    def _do_exploit_suggester(self):
        self._send_command("use post/multi/recon/local_exploit_suggester")
        self._send_command("set SESSION {}".format(self._current_session))
        return self._send_command("run")

    def _do_portscan(self, host):
        self._send_command("use auxiliary/scanner/portscan/tcp")
        self._send_command("set RHOSTS {}".format(host))
        self._send_command("set PORTS {}".format(self._scan_ports))
        return self._send_command("run")

    def _do_pingsweep(self, route):
        return self._send_command(
            "run post/multi/gather/ping_sweep RHOSTS={}".format(route)
        )

    def _set_current_session_id(self, data):
        try:
            start = data.find("session") + 8
            end = data.find("opened") - 1
            self._current_session = int(data[start:end])
            return True
        except Exception as error:
            logger.error("Error setting session ID: %s", error)
            return False

    def _meterpreter_session_opened(self, data):
        if self._visualizations:
            self._visualizer.graph_advance(status=2)
        if not self._set_current_session_id(data):
            return False
        if self._exec_mode == 'single':
            return True
        self.sleep(5)
        # Ensure we are interacting with the meterpreter session
        if not self._send_command('sessions {}'.format(self._current_session)):
            logger.error("Could not interact with session")
            return False
        # Detect and create routes through host
        if not self._do_autoroute():
            logger.warning("Autoroute failed")
            return False
        # Background the session
        if not self._send_command('bg'):
            logger.warning("Could not background session")
        return True

    def _command_shell_opened(self, data):
        if self._visualizations:
            self._visualizer.graph_advance(status=1)
        self._set_current_session_id(data)
        if self._exec_mode == 'single':
            return True
        # Attempt to sudo
        # if not self.do_sudo():
        #    logger.warning("Attempt to sudo w/in command shell failed")
        if not self._do_upgrade():
            logger.warning(
                "Unable to upgrade command shell session to meterpreter"
            )
            return False
        return True

    def _do_sudo(self):
        self._send_command('use post/multi/manage/sudo')
        self._send_command('set SESSION $session')
        self._send_command('set PASSWORD $password')
        return self._send_command('run')

    def _do_upgrade(self):
        return self._send_command('sessions -u $session')

    def _do_autoroute(self):
        return self._send_command('run post/multi/manage/autoroute')

    def _is_failure_response(self, response):
        data = response['data']
        if self.failure_pattern.search(data) is not None:
            logger.debug('*** Found failure in %s', data)
            return True
        return False

    def _is_successful_response(self, response):
        data = response['data']
        success = False
        if self.success_pattern.search(data) is not None:
            logger.debug('*** Found success in %s', data)
            success = True
            if self.session_success_pattern.search(data) is not None:
                start = data.find("session") + 8
                end = data.find("opened") - 1
                self._current_session = int(data[start:end])
                if self.command_shell_success_pattern.search(data) is not None:
                    self._do_sudo()
                    if self._do_upgrade():
                        success = self._do_autoroute()
        return success

    @classmethod
    def parse_values(cls, values):
        '''Given values from an attack step, parse into dictionary
        For example:
            values="module=auxiliary/scanner/scada/modbusclient
                    rhost=192.168.10.250 action=WRITE_REGISTERS
                    data_address=2 data_registers=30 unit_number=255"
            result={'MODULE': 'auxiliary/scanner/scada/modbusclient',
                    'RHOST': '192.168.10.250',
                    'ACTION': 'WRITE_REGISTERS',
                    'DATA_ADDRESS': '2',
                    'DATA_REGISTERS': '30',
                    'UNIT_NUMBER': '255'}
        Arguments:
            values(str): String describing the metasploit module and values
        Returns:
            dict: Dictionary of metasploit values to set
        '''
        result = {}
        if values.startswith('cmd'):
            return {'CMD': values.split('=')[1]}
        key_values = values.strip().split(' ')
        for key_value in key_values:
            if '=' in key_value:
                key, value = key_value.split('=')
                result[key.upper()] = value
            else:
                logger.error(
                    'Error: could not find enough values in "%s"', values
                )
        logger.debug('parse_values: values=%s, result=%s', values, result)
        return result

    def print_tree(self):
        """Display all the attack trees to standard out."""
        for attack_tree in self.attack_trees:
            self._print_tree2(attack_tree)

    @classmethod
    def _print_tree2(cls, attack_tree):
        hop_list = attack_tree['hops']
        for hop_num, hop in enumerate(hop_list):
            node = hop['node']
            action_list = hop['actions']
            logger.debug('    Hop #%s, Node: %s', hop_num, node)

            for action_num, action in enumerate(action_list):
                logger.debug('        Action #%s: %s', action_num, action)
        logger.debug(
            '================================================================'
        )
