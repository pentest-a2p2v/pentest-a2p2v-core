#!/usr/bin/python3
#
#  Copyright (C) 2018-2021 Toshiba Corporation and Perspecta Labs, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

""" This module defines an algorithm that finds all attack trees that achieve
    a specified goal.  It is a modified version of traditional graph search.
    A network topology is used to define a graphs.  Vulnerabilities and
    services allow an attacker to gain access.  And the attacker state keeps
    track of what the attacker has achieved or learned.
"""
import ast
import logging
import copy
import sys
import re

from .types import CapabilitySeverity, CapabilityRank, Credential
from .config import config
from .config import get_config_filename
from .types import AccessClass, UserRole, FindMode

ip_prefix_pattern = re.compile(r'(\d+.\d+.\d+).(\d+)')

logger = logging.getLogger(__name__)


##########################################
# Holds information about the state of the current attack tree
class State:
    """This class is used to hold information about system state during planning"""

    def __init__(self, current_host=None, current_status=None):
        """Represents a state of the attacker
        Arguments:
            current_host(str): name of host which the attacker has access
            current_status(Set[str]): status (capability names or items set
                by post conditions)
        """
        if current_status is None:
            current_status = set()

        self.current_host = current_host
        self.current_status = current_status
        self.initial_host = (
            None  # Stores the initial host (generally the attacker)
        )
        self.current_role = (
            UserRole.NONE
        )  # Stores the current user role on the current host (See UserRole)
        self.current_access = (
            AccessClass.NONE
        )  # Stores the current access type on the current host (See AccessClass)
        self.temp = {}  # Dictionary to temporarily hold parameters and values
        # to be passed from precondition to postcondition
        self.credentials = (
            []
        )  # List of Credential instances with credentials held in current state

    def clear_current_status(self):
        """Resets current status (empties it)"""
        logger.debug("Clearing current status")
        self.current_status = set()

    def clear_current_host(self):
        """Resets current host (empties it)"""
        logger.debug("Clearing current host")
        self.current_host = None

    def add_credential(
        self,
        credential_host,
        credential_user_role,
        credential_username=None,
        credential_password=None,
        credential_hash=None,
    ):
        """
        Arguments:
            credential_host(str): the host name or IP address this credential is for (required)
            credential_user_role(str): the user role associated with the credential (required)
            credential_username(str): the username portion of the credential (optional)
            credential_password(str): the password portion of the credential (optional)
            credential_hash(str): a hash/token which represents a username/password (optional)
        """

        # If a credential already exists for the specified host with the specified role, just return
        if self.get_credential(credential_host, credential_user_role):
            return
        new_credential = Credential(
            credential_host,
            credential_user_role,
            credential_username,
            credential_password,
            credential_hash,
        )
        self.credentials.append(new_credential)

    def get_credential(self, credential_host, min_user_role):
        """
        Arguments:
            credential_host(str): hostname
            min_user_role(str): minimum role to find ( 'none', 'user', or 'admin')
        Returns:
            dict: containing 'username', 'password' and 'role' or None
        """
        result = None
        for credential in self.credentials:
            if (
                credential.host == credential_host
                and UserRole[credential.role.upper()]
                >= UserRole[min_user_role.upper()]
            ):
                if credential.role == 'admin':
                    logger.debug("Found an admin role credential")
                    result = {
                        "username": credential.username,
                        "password": credential.password,
                        "role": credential.role,
                    }
                    return result
                else:
                    logger.debug("Found a non-admin role credential")
                    result = {
                        "username": credential.username,
                        "password": credential.password,
                        "role": credential.role,
                    }
        return result

    def __str__(self):
        """Provides an easy way to print status information"""
        return (
            'state: status={}, initial_host={}, current_host={}, '
            'current_role={}, current_access={}, credentials={}'.format(
                self.current_status,
                self.initial_host,
                self.current_host,
                self.current_role,
                self.current_access,
                self.credentials,
            )
        )

    def __repr__(self):
        """Provides an easy way to print status information"""
        return self.__str__()


class Planner:
    """This class performs planning functions"""

    def __init__(
        self,
        capabilities,
        host_capabilities,
        network_graph,
        switch_visits=1,
        max_hops=5,
    ):
        """Constructor:  set up configuration and logger"""
        self.capabilities = capabilities
        self.network_graph = network_graph
        self.host_capabilities = host_capabilities
        self.switch_visits = switch_visits
        self.max_hops = max_hops

        self.goals = []
        self.sensitives = []
        self.state = State()
        self.attack_trees = []
        self.get_sensitive_states()
        self.score_weights = ast.literal_eval(
            config.get('PLANNING', 'score_weights')
        )

    @classmethod
    def preloaded_planner(cls, attack_trees):
        """Used when attack trees are loaded from JSON file"""
        self = cls.__new__(cls)
        self.attack_trees = attack_trees
        return self

    def hostname_to_ips(self, target, network=None):
        """
        Arguments:
            target(str): hostname
            network(str): optional: network component (e.g. "192.168.20")
        Returns:
            list(str): list of IP addresses
        """
        ips = []
        if target in self.host_capabilities.keys():
            interfaces = self.host_capabilities[target]['interfaces']
            for interface in interfaces:
                if not network:
                    ips.append(interface[0])
                elif network and interface[0].startswith(network):
                    ips.append(interface[0])

        return ips

    def ip_to_hostname(self, target):
        """Given an IP, look up the hostname.
           Given a hostname, simply return the same hostname.
        Arguments:
            target(str): ip address (or hostname)
        Returns:
            str: the corresponding hostname
        """
        if target not in self.host_capabilities.keys():
            for host, host_details in self.host_capabilities.items():
                if target in [
                    interface[0] for interface in host_details['interfaces']
                ]:
                    logger.debug(
                        "IP address %s resolved to host %s", target, host
                    )
                    target = host

        return target

    def host_match(self, host1, host2):
        """Match host1 against host2 with wildcard match if either is *.
            Also matches if either host is an IP on the other.
        Arguments:
            host1(str): first host to match against (may be hostname, IP address or wildcard [*])
            host2(str): second host to match against (may be hostname, IP address or wildcarde [*])
        Returns:
            bool: If a match has been made
        """
        return (
            host1 == host2
            or (isinstance(host1, str) and isinstance(host2, str) and host1.lower() == host2.lower())
            or host1 in self.hostname_to_ips(host2)
            or host2 in self.hostname_to_ips(host1)
            or host1 == '*'
            or host2 == '*'
        )

    def ip_from_nic_node(self, node):
        """Get the IP address of a nic node
        Arguments:
            node(str): the node (assumed to be a NIC) to get the IP address for
        Returns:
            str: IP address of the nic
        """
        ip_address = self.network_graph.nodes[node]['node_id']

        if not ip_address:
            logger.error("Can't resolve interface %s", node)
        return ip_address

    def is_derived(self, capability_id):
        """Test if a capability is a derived capability by checking
            if there are any 'capability' type preconditions
        Arguments:
            capability_id(str): the ID of the capability to test
        Returns:
            bool: If the capability is derived or not
        """

        if capability_id in self.capabilities.keys():
            for precondition in self.capabilities[capability_id].preconditions:
                if precondition['type'] == 'capability':
                    return True
        return False

    def get_parent_capability_id(self, capability_id):
        """Returns the parent capability_id for a derived capability
        Arguments:
            capability_id(str): the ID of the derived capability
        Returns:
            capability_id(str): the parent capability ID
        """

        if self.is_derived(capability_id):
            parent_capability_id = '.'.join(capability_id.split('.')[:-1])
            return parent_capability_id

        return None

    def is_passive(self, node):
        """Test if a node is passive
        Arguments:
            node(str): the node to test
        Returns:
            bool: If the node is passive or not
        """
        return bool(self.network_graph.nodes[node]['node_passive'])

    def is_switch(self, node):
        """Test if a node is a switch
        Arguments:
            node(str): the node to test
        Returns:
            bool: If the node is a switch or not
        """
        return self.network_graph.nodes[node]['nodeType'] == 'switch'

    def is_nic(self, node):
        """Test if a node is a NIC
        Arguments:
            node(str): the node to test
        Returns:
            bool: If the node is a NIC or not
        """
        return self.network_graph.nodes[node]['nodeType'] == 'interface'

    def set_initial_state(self, initial_host=None):
        """Sets planner initial state from configuration file
        Arguments: None
        Returns:   None
        """
        logger.debug("Setting Initial State")
        if not self.state:
            self.state = State()

        for state_item in config.options('INITIAL CONDITIONS'):
            new_state = ast.literal_eval(
                config.get('INITIAL CONDITIONS', state_item)
            )
            # Provide command line override
            if initial_host is not None:
                self.state.initial_host = initial_host.upper()
                self.state.current_host = initial_host.upper()

            if new_state['type'].lower() == 'state':
                if new_state['key'] == "initial_host" and initial_host is None:
                    initial_host = new_state['value'].upper()
                    self.state.initial_host = initial_host.upper()
                    self.state.current_host = initial_host.upper()
                if new_state['key'] == "current_role":
                    self.state.current_role = UserRole[
                        new_state['value'].upper()
                    ]
                if new_state['key'] == "current_access":
                    self.state.current_access = AccessClass[
                        new_state['value'].upper()
                    ]
            elif new_state['type'].lower() == 'credential':
                if (
                    'host' not in new_state.keys()
                    or 'role' not in new_state.keys()
                ):
                    logger.error(
                        "Initial state: Invalid credential. "
                        "Missing required host or role information"
                    )
                    return
                credential_host = new_state['host'].upper()
                credential_user_role = new_state['role']
                credential_username = None
                credential_password = None
                credential_hash = None
                if 'username' in new_state.keys():
                    credential_username = new_state['username'].lower()
                if 'password' in new_state.keys():
                    credential_password = new_state['password']
                if 'hash' in new_state.keys():
                    credential_hash = new_state['hash']
                if not credential_hash and not credential_username:
                    logger.error(
                        "Initial state: Invalid credential.  "
                        "Must include either hash or username/password"
                    )
                    return
                self.state.add_credential(
                    credential_host,
                    credential_user_role,
                    credential_username,
                    credential_password,
                )

    def test_preconditions(self, target_host, capability):
        """Test if preconditions are met for a capability on a host
            (assumes current host is neighbor of target host)
        Arguments:
            target_host(str): the host to check capability preconditions on
            capability(Capability): the capability to check
        Returns:
            bool: If the preconditions can be met or not
        """

        logger.debug(
            'test_preconditions() Entered: targetHost=%s, capability=%s',
            target_host,
            capability.capability_id,
        )

        num_required = len(capability.preconditions)
        for precondition in capability.preconditions:
            condition_met = False
            pc_host = precondition['host']
            pc_type = precondition['type']
            pc_key = precondition['key']
            pc_value = precondition['value']
            if pc_type == 'service':
                condition_met = True
            elif pc_type == 'state':
                condition_met = self._parse_precondition_state(
                    pc_host, pc_key, pc_value, target_host
                )
            elif pc_type == 'capability':
                condition_met = self._parse_precondition_capability(
                    pc_value, target_host
                )
            elif pc_type == 'credential':
                condition_met = self._parse_precondition_credential(
                    capability, pc_value, target_host
                )

            if condition_met:
                num_required -= 1

        if num_required == 0:
            logger.debug(
                "We've satisfied all the pre-conditions for this capability!"
            )
            return True

        logger.debug(
            "We could not satisfy all the pre-conditions for this capability (%s left)",
            num_required,
        )
        return False

    def _parse_precondition_credential(
        self, capability, pc_value, target_host
    ):
        condition_met = False
        required_user_role = pc_value
        logger.debug(
            "Required Credential for User Role: %s", required_user_role
        )
        credential = self.state.get_credential(target_host, required_user_role)
        if credential:
            logger.debug("Credential requirement met")
            condition_met = True
            self.state.temp['role'] = credential['role']
        else:
            for action in capability.actions:
                if '$$' in action['value']:
                    logger.warning(
                        "Allowing a precondition to pass with a "
                        "default credential based on action: %s",
                        action['value'],
                    )
                    condition_met = True
            if not condition_met:
                logger.debug("Credential requirement not met")
        return condition_met

    def _parse_precondition_capability(self, pc_value, target_host):
        condition_met = False
        logger.debug("Required Capability: %s", pc_value)
        for icapability in self.capabilities.keys():
            if self.capabilities[icapability].subclass == pc_value:
                condition_met = self.test_preconditions(
                    target_host, self.capabilities[icapability]
                )
        return condition_met

    def _parse_precondition_state(
        self, pc_host, pc_key, pc_value, target_host
    ):
        condition_met = False
        current_access_level = self.state.current_access
        current_user_role = self.state.current_role
        current_status = self.state.current_status
        if pc_key == 'current_access':
            required_access_level = AccessClass[pc_value.upper()]
            logger.debug(
                "Access level on Current host (%s): %s, "
                "Required Access level: %s target host: %s",
                self.state.current_host,
                current_access_level,
                required_access_level,
                target_host,
            )
            if pc_host == '$current_host' or (
                pc_host == '$target_host'
                and target_host == self.state.current_host
            ):
                if (
                    current_access_level
                    and current_access_level >= required_access_level
                ):
                    logger.debug("Current Access requirement met")
                    condition_met = True
                else:
                    logger.debug("Current Access requirement not met")
        elif pc_key == 'current_role':
            required_user_role = UserRole[pc_value.upper()]
            logger.debug(
                "Current User Role: %s, Required User Role: %s",
                current_user_role,
                required_user_role,
            )
            if current_user_role >= required_user_role:
                condition_met = True
        elif pc_key == 'current_status':
            logger.debug(
                "Current Status: %s, Required Status: %s",
                current_status,
                pc_value,
            )
            if pc_value in current_status:
                logger.debug("Current Status requirement met")
                condition_met = True
            else:
                logger.debug("Current Status requirement not met")
        return condition_met

    def find_all_vulns(self, host=None):
        """Find all vulnerabilities for a given host, or for all hosts if none is specified
        Arguments:
            host(str): the host to find vulnerabilities on (optional)
        Returns: None
        """
        if host and host != 'None':
            self.find_all_host_vulns(host.upper())
        else:
            for host_name in self.host_capabilities.keys():
                self.find_all_host_vulns(host_name)

    def get_capability_protoport(self, capability_id):
        """Given a capability name, return the protocol and port (e.g. TCP/22 for ssh)
        Arguments:
            capability_id(str): The capability name
        Returns:
            protoport(str): The protocol and port number for the capability
        """
        protoport = "N/A"
        while self.is_derived(capability_id):
            capability_id = self.get_parent_capability_id(capability_id)
        for condition in self.capabilities[capability_id].preconditions:
            if condition['type'] == 'service':
                protoport = condition['value']

        return protoport.upper()

    def find_all_host_vulns(self, host):
        """Find all vulnerabilities for a given host in single host mode
        Arguments:
            host(str): the host to find vulnerabilities on
        Sets:
            self.attack_trees(): JSON formatted attack trees
        Returns: None
        """
        for host_capability in self.host_capabilities[host]['capabilities']:
            full_capability = self.capabilities[host_capability]
            protocol_port = self.get_capability_protoport(host_capability)
            capability_label = "{} ({})".format(
                full_capability.title.upper(), protocol_port
            )
            host_tree = {
                'hops': [],
                'score': {'severity': 0, 'services': 0, 'exploits': 0},
            }
            capability_actions = self.get_actions(host, host_capability)
            if capability_actions:
                self.state.clear_current_status()
                self.update_status(host_capability)
                sensitivity = self.check_sensitive()
                new_node = {
                    "node": host,
                    "options": [
                        {
                            "capability": capability_label,
                            "class": full_capability.capability_class,
                            "solution": full_capability.solution,
                            "severity": full_capability.severity,
                            "rank": full_capability.rank,
                            "actions": capability_actions,
                        }
                    ],
                }
                if full_capability.cves:
                    new_node['options'][0]['cves'] = full_capability.cves
                if sensitivity:
                    new_node['options'][0]['sensitivity'] = sensitivity

                host_tree['hops'].append(new_node)

                self.add_attack_tree(host_tree)

        return

    def combined_score(self, attack_tree):
        """Computes combined score for attack trees given certain criteria about the path.
        Arguments:
            attack_tree(dict): The attack tree to compute scoring for
        Returns:
            (float): The weighted combined score for the tree
        """
        return round(
            10
            + self.score_weights['NUM_EXPLOITS']
            * attack_tree['score']['exploits']
            + self.score_weights['LENGTH'] * attack_tree['score']['len']
            + self.score_weights['SEVERITY'] * attack_tree['score']['severity']
            + self.score_weights['NUM_SERVICES']
            * attack_tree['score']['services'],
            2,
        )

    def add_attack_tree(self, attack_tree):
        """Adds a new attack tree to the list of attack trees and checks to ensure no duplicates
        Arguments:
            attack_tree(dict): a successful attack tree to add to the global list
        Sets:
            self.attack_trees(): JSON formatted attack trees
        Returns: None
        """

        this_attack_tree = copy.deepcopy(attack_tree)

        this_attack_tree['score']['len'] = len(attack_tree['hops'])
        severity = exploits = services = 0
        for hop_num, hop in enumerate(attack_tree['hops']):
            this_attack_tree['hops'][hop_num]['options'] = sorted(
                hop['options'],
                key=lambda i: CapabilityRank[i['rank'].upper()].value,
                reverse=True,
            )
            for option in hop['options']:
                severity += CapabilitySeverity[
                    option['severity'].upper()
                ].value
                if option['class'] == 'service':
                    services += 1
                if option['class'] == 'exploit':
                    exploits += 1
            severity = round(severity / len(hop['options']), 2)
            services = round(services / len(hop['options']), 2)
            exploits = round(exploits / len(hop['options']), 2)

        this_attack_tree['score']['severity'] = severity
        this_attack_tree['score']['services'] = services
        this_attack_tree['score']['exploits'] = exploits
        this_attack_tree['score']['combined'] = self.combined_score(
            this_attack_tree
        )

        if 'goals' in attack_tree.keys():
            this_attack_tree['goals'] = list(attack_tree['goals'])

        if self.is_duplicate_tree(this_attack_tree):
            logger.debug(
                "Duplicate tree: %s->%s",
                this_attack_tree['hops'][0]['node'],
                this_attack_tree['hops'][-1]['node'],
            )
            return

        logger.debug(
            "Adding attack tree: %s->%s",
            this_attack_tree['hops'][0]['node'],
            this_attack_tree['hops'][-1]['node'],
        )
        self.attack_trees.append(this_attack_tree)

    def is_duplicate_tree(self, tree):
        """Detects duplicate trees
        Arguments:
            tree(dict): The tree to check
        Returns:
            (bool): If the tree is a duplicate or not
        """
        for attack_tree in self.attack_trees:
            if tree == attack_tree:
                logger.debug("Duplicate tree detected")
                return True

        return False

    def find_all_paths(
        self, tree=None, start=None, path=None, last_interface_ip=None
    ):
        """Find all paths given a start, graph and goal.  Used in system planning mode
        Args:
            tree(dict): Current potential attack tree
            start(str): hostname of the node to start with for this iteration
            path(list): path built up (includes all nodes including passive)
            last_interface_ip(str): IP address last passed through in the path
        Sets:
            self.attack_trees(): JSON formatted attack trees
        Returns: None
        """

        if start is None:
            start = self.state.initial_host
        if tree is None:
            tree = {"hops": [], "score": {}, "goals": set()}
        if path is None:
            path = []

        if len(tree['hops']) > self.max_hops:
            return

        my_tree = copy.deepcopy(tree)
        pre_node_state = copy.deepcopy(self.state)
        logger.debug(
            'Entered: find_all_paths(tree=%s, state=%s, current node=%s, path=%s)',
            tree,
            self.state,
            start,
            path,
        )
        for node in self.network_graph[start]:
            logger.debug("Trying node: %s", node)
            actions = {'actions': []}
            if self._should_process_node(node, path):
                # if node not in path or
                # ( self.is_switch(node) and path.count(node) < self.switchVisits ):
                if node == self.state.initial_host or self.is_passive(node):
                    logger.debug('Adding node %s to current path', node)
                    if self.is_nic(node):
                        last_interface_ip = self.ip_from_nic_node(node)
                else:
                    target_host = self.ip_to_hostname(
                        self.network_graph.nodes[node]['node_id']
                    )

                    target_host_goal_id = self.check_target_host_goal(
                        target_host
                    )
                    if target_host_goal_id:
                        logger.debug(
                            "Met target host goal: %s", target_host_goal_id
                        )
                        my_tree['goals'].add(target_host_goal_id)
                        self.add_attack_tree(my_tree)
                        return  # Unwind

                    goal_hop_options = []
                    access_hop_options = []
                    new_hop = {"node": node, "options": []}
                    mode = FindMode.GOAL

                    while True:
                        # Iterate twice.  Once looking for goals, once looking for access.
                        capability_index = 0
                        while capability_index < len(
                            self.host_capabilities[target_host]['capabilities']
                        ):
                            logger.debug(
                                "Capability index %s on %s",
                                capability_index,
                                target_host,
                            )
                            self.state.clear_current_status()
                            self.state.clear_current_host()
                            host_capability_name = self.host_capabilities[
                                target_host
                            ]['capabilities'][capability_index]

                            full_capability = self.capabilities[
                                host_capability_name
                            ]

                            # Check if capability preconditions are met
                            logger.debug(
                                "Trying capability %s on %s",
                                host_capability_name,
                                target_host,
                            )
                            if self.test_preconditions(
                                target_host, full_capability
                            ):
                                self._use_capability(
                                    access_hop_options,
                                    full_capability,
                                    goal_hop_options,
                                    host_capability_name,
                                    last_interface_ip,
                                    mode,
                                    my_tree,
                                    node,
                                    target_host,
                                )

                            logger.debug("Incrementing capability index")
                            capability_index += 1

                        # End Capability Loop: All capabilities have been tried
                        if mode == FindMode.GOAL:
                            logger.debug("Evaluate 'goal' mode options")
                            if len(goal_hop_options) > 0:
                                logger.debug(
                                    "We have goals in phase 0!: %s",
                                    goal_hop_options,
                                )
                                new_hop['options'] = goal_hop_options
                                if not new_hop in my_tree['hops']:
                                    my_tree['hops'].append(new_hop)
                                self.add_attack_tree(my_tree)
                                # If the goal reached is host specific,
                                # stop exploring this path and return
                                for goal in my_tree['goals']:
                                    if self.is_goal_host_specific(goal):
                                        # Restore state to that before this node was accessed
                                        self.state = copy.deepcopy(
                                            pre_node_state
                                        )
                                        return
                            logger.debug("Setting mode to 'Access'")
                            mode = FindMode.ACCESS
                            continue
                        elif mode == FindMode.ACCESS:
                            if len(access_hop_options) > 0:
                                logger.debug(
                                    "We have access in phase 1!: %s",
                                    access_hop_options,
                                )
                                new_hop['options'] = access_hop_options
                                if not new_hop in my_tree['hops']:
                                    my_tree['hops'].append(new_hop)
                                else:
                                    logger.debug("Duplicate hop: %s", new_hop)
                                break
                            else:
                                logger.debug(
                                    "Mode is 1 and no access on this host"
                                )
                                # Restore state to that before this node was accessed
                                self.state = copy.deepcopy(pre_node_state)
                                return

                    # End of double loop through capabilities

                path = path + [node]
                self.find_all_paths(my_tree, node, path, last_interface_ip)

            logger.debug(
                "Node %s is already in path, or is a switch that's been limited in visits",
                node,
            )

        logger.debug(
            "No more neighbor nodes for this branch or switch visit limit hit"
        )
        # Restore state to that before this node was accessed
        self.state = copy.deepcopy(pre_node_state)
        return  # No more neighbor nodes in this branch

    def _use_capability(
        self,
        access_hop_options,
        full_capability,
        goal_hop_options,
        host_capability_name,
        last_interface_ip,
        mode,
        my_tree,
        node,
        target_host,
    ):
        logger.debug('Capability can be used!')
        # Store state before trying a capability
        pre_capability_state = copy.deepcopy(self.state)
        # Set postconditions in state
        self.set_post_conditions(target_host, host_capability_name)
        state_change = self.check_state_change(pre_capability_state)
        logger.debug(
            "Mode: %s, StateChange: %s",
            mode,
            state_change,
        )
        if (
            mode == FindMode.GOAL
            and state_change['goal']
            or mode == FindMode.ACCESS
            and state_change['target_access']
        ):
            self._mark_progress(
                access_hop_options,
                full_capability,
                goal_hop_options,
                host_capability_name,
                last_interface_ip,
                mode,
                my_tree,
                node,
                state_change,
                target_host,
            )

        elif (
            mode == FindMode.ACCESS
            and state_change['role_esc']
            or state_change['access_esc']
            or state_change['new_cred']
        ):
            # Not currently handled
            pass

    def _mark_progress(
        self,
        access_hop_options,
        full_capability,
        goal_hop_options,
        host_capability_name,
        last_interface_ip,
        mode,
        my_tree,
        node,
        state_change,
        target_host,
    ):
        logger.debug(
            "We have progress with this capability: %s",
            state_change,
        )
        actions = self.get_actions(
            node,
            host_capability_name,
            host_ip=last_interface_ip,
        )
        protocol_port = self.get_capability_protoport(host_capability_name)
        capability_label = "{} ({})".format(
            full_capability.title.upper(),
            protocol_port,
        )
        new_option = {
            "capability": capability_label,
            "class": full_capability.capability_class,
            "severity": full_capability.severity,
            "rank": full_capability.rank,
            "cves": full_capability.cves,
            "solution": full_capability.solution,
            "actions": actions,
        }
        if state_change["sensitive"]:
            new_option["sensitivity"] = state_change["sensitive"]
        if mode == FindMode.GOAL and state_change['goal']:
            logger.debug(
                "Goal met with capability %s on %s",
                host_capability_name,
                target_host,
            )
            goal_hop_options.append(new_option)
            my_tree['goals'].add(state_change['goal'])

        elif mode == FindMode.ACCESS and state_change['target_access']:
            logger.debug(
                "Target access gained with capability %s on %s",
                host_capability_name,
                target_host,
            )
            access_hop_options.append(new_option)

    def _should_process_node(self, node, path):
        return (
            node not in path
            or (self.is_nic(node) and path.count(node) < self.switch_visits)
            or (self.is_switch(node) and path.count(node) < self.switch_visits)
        )

    def check_target_access(self, pre_state):
        """Checks if current host in current state is different than in previous state
        Arguments:
            pre_state(State): Previous state
        Returns:
            (bool): If the current host has changed or not
        """
        return pre_state.current_host != self.state.current_host

    def check_role_esc(self, pre_state):
        """Checks if current role is more privileged than the previous role
        Arguments:
            pre_state(State): Previous state
        Returns:
            (bool): If the current roles has been elevated or not
        """
        return pre_state.current_role < self.state.current_role

    def check_access_esc(self, pre_state):
        """Checks if current access is greater than the previous access
        Arguments:
            pre_state(State): Previous state
        Returns:
            (bool): If the current access is greater or not
        """
        return pre_state.current_access < self.state.current_access

    def check_new_credential(self, pre_state):
        """Checks if a new credential has been acquired since previous state
        Arguments:
            pre_state(State): Previous state
        Returns:
            (bool): If a new credential has been acquired or not
        """
        return len(pre_state.credentials) > len(self.state.credentials)

    def check_state_change(self, pre_state):
        """Compares post state vs pre state to see if progress has been made
            and/or any goals have been met
        Arguments:
            pre_state(State): State prior to capability being used
        Returns:
            result(dict): A dictionary with result information
                      target_access (bool): Indicates whether access was gained to the target
                      role_esc (bool)       Indicates role elevation
                      access_esc (bool)     Indicates access elevation
                      new_cred (bool)       Indicates a new credential was added
                      goal(str)             Name of a goal if met
                      sensitive(dict)       a dictionary with information regarding
                                            sensitive host or state reached
        """
        logger.debug("Checking to see if state has been positively changed")
        logger.debug("preState: %s", pre_state)
        logger.debug("postState: %s", self.state)

        result = {}
        result["target_access"] = self.check_target_access(pre_state)
        result["role_esc"] = self.check_role_esc(pre_state)
        result["access_esc"] = self.check_access_esc(pre_state)
        result["new_cred"] = self.check_new_credential(pre_state)
        result["sensitive"] = self.check_sensitive()
        result["goal"] = self.check_goal_reached()

        return result

    def check_current_host_goal(self, goal_host):
        """Check to see if a current host goal has been reached
        Arguments:
            goal_host(string): The host to which access to satisfies a goal
        Returns:
            (bool): If access to the goal host has been gained or not
        """
        if self.host_match(goal_host, self.state.current_host):
            logger.debug("Reached Current Host Goal: %s", goal_host)
            return True
        return False

    def check_target_host_goal(self, target_host):
        """Check to see if a target host goal has been reached
        Arguments:
            target_host(string): The host to which network reachability satisfies a goal
        Returns:
            (bool): If target host is network reachable or not
        """
        for goal in self.goals:
            if goal['key'] == 'target_host' and self.host_match(
                target_host, goal['value']
            ):
                logger.debug("Reached Target Host Goal on: %s", target_host)
                return goal['id']
        return None

    def check_current_status_goal(self, goal_status, goal_host):
        """Check to see if a current status goal has been reached
        Arguments:
            goal_status(string): The status which satisfies a goal
            goal_host(string): The host on which the status should be reached (or * for all)
        Returns:
            (bool): If target status has been reached or not
        """
        if goal_status in self.state.current_status and self.host_match(
            goal_host, self.state.current_host
        ):
            logger.debug("Reached Current Status Goal on: %s", goal_status)
            return True
        return False

    def check_current_access_goal(self, goal_access, goal_host):
        """Check to see if a current access goal has been reached
        Arguments:
            goal_access(string): The access which satisfies a goal
            goal_host(string): The host on which the access should be reached (or * for all)
        Returns:
            (bool): If target access has been reached or not
        """
        if AccessClass[
            goal_access.upper()
        ] == self.state.current_access and self.host_match(
            goal_host, self.state.current_host
        ):
            logger.debug("Reached Current Access Goal on: %s", goal_host)
            return True
        return False

    def check_current_role_goal(self, goal_role, goal_host):
        """Check to see if a current role goal has been reached
        Arguments:
            goal_role(string): The role which satisfies a goal
            goal_host(string): The host on which the role should be reached (or * for all)
        Returns:
            (bool): If target role has been reached or not
        """
        if UserRole[
            goal_role.upper()
        ] == self.state.current_role and self.host_match(
            goal_host, self.state.current_host
        ):
            logger.debug("Reached Current Role Goal on: %s", goal_host)
            return True
        return False

    def is_goal_host_specific(self, goal_id):
        """Check to see if a goal is host specific (determines path building)
        Arguments:
            goal_id(string): The name of the goal to check
        Returns:
            (bool): If the goal is host specific or not
        """
        for goal in self.goals:
            if goal_id == goal['id']:
                if goal['key'] == 'current_host' or 'host' in goal.keys():
                    return True

        return False

    def check_goal_reached(self):
        """Checks current state to see if a goals have been reached
        Returns:
        (list): A list containing the goalIDs of any goals met
        """
        logger.debug("Checking current state against goal states")
        for goal in self.goals:
            goal_id = goal['id']
            goal_key = goal['key']
            goal_value = goal['value']
            try:
                goal_host = goal['host']
            except:
                goal_host = '*'
            if (
                goal_key == 'current_host'
                and self.check_current_host_goal(goal_value)
                or goal_key == 'current_status'
                and self.check_current_status_goal(goal_value, goal_host)
                or goal_key == 'current_access'
                and self.check_current_access_goal(goal_value, goal_host)
                or goal_key == 'current_role'
                and self.check_current_role_goal(goal_value, goal_host)
            ):
                logger.debug("Met Goal %s!", goal_id)
                return goal_id

        return None

    def check_sensitive(self):
        """Checks given state to see if any sensitive states have been reached
        Returns:
        (dict): 2 values, first being 'type' of sensitive state (host or status)
                second being 'value' for which host or status applied
        """
        logger.debug("Checking sensitive state")
        sensitive = {}
        logger.debug(
            "Current Status in check_sensitive: %s", self.state.current_status
        )
        for sensitive_item in self.sensitives:
            sensitive_key = sensitive_item['key']
            sensitive_value = sensitive_item['value']
            if (
                sensitive_key == 'current_host'
                and self.state.current_host
                and self.host_match(
                    sensitive_value.upper(), self.state.current_host
                )
            ):
                logger.debug("Reached Sensitive Host: %s", sensitive_value)
                sensitive["type"] = "host"
                sensitive["value"] = sensitive_value
            elif (
                sensitive_key == 'current_status'
                and sensitive_value in self.state.current_status
            ):
                logger.debug("Reached Sensitive State: %s", sensitive_value)
                sensitive["type"] = "status"
                sensitive["value"] = sensitive_value

        return sensitive

    def get_credential_value(
        self, host: str, parameter: str, min_role: str = 'user'
    ) -> str:
        """Obtain a parameter from the credentials
        Arguments:
            host (str): hostname
            parameter (str): parameter, e.g. 'username', 'password'
            min_role (str): minimum role the user should have, default: 'user'
        Returns:
            str: the value of the parameter (or if it can not be determined: $parameter)
        """
        value = f'${parameter}'

        if self.state:
            credential = self.state.get_credential(host, min_role)

            if credential:
                value = credential.get(parameter, f'${parameter}')

        return value

    def get_actions(self, host, capability_id, host_ip=None):
        """Get the actions for a particular capability, filling any variables
        Arguments:
            host(str):
            capability_id(str):
            host_ip(str):
        Returns:
        (list): List of action dictionaries
        """
        capability = self.capabilities[capability_id]

        if not host_ip:
            host_ip = list(self.host_capabilities[host]['interfaces'])[0][0]

        if capability.capability_class == 'service':
            logger.debug(
                "Getting actions for service capability: %s on host: %s with IP Address: %s",
                capability.subclass,
                host,
                host_ip,
            )
        else:
            logger.debug(
                "Getting actions for exploit capability: %s:%s on host: %s with IP Address: %s",
                capability.subclass,
                capability.cves,
                host,
                host_ip,
            )
        final_actions = []
        if capability.actions:
            logger.debug(
                "Found actions for capability: %s", capability.actions
            )
            actions = self.resolve_capability_action(capability, {}, [])

            logger.debug("Resolved actions for capability: %s", actions)
            for action in actions:
                new_action = copy.deepcopy(action)
                if '$target_host' in new_action['value']:
                    new_action['value'] = new_action['value'].replace(
                        '$target_host', host_ip
                    )
                    logger.debug("Replacing $target_host with %s", host_ip)
                if '$username' in new_action['value']:
                    username = self.get_credential_value(host, 'username')
                    new_action['value'] = new_action['value'].replace(
                        '$username', username
                    )
                    logger.debug("Replacing $username with %s", username)
                if '$password' in new_action['value']:
                    password = self.get_credential_value(host, 'password')
                    new_action['value'] = new_action['value'].replace(
                        '$password', password
                    )
                    logger.debug("Replacing $password with %s", password)
                if '$hash' in new_action['value']:
                    ahash = self.state.get_credential_value(host, 'hash')
                    new_action['value'] = new_action['value'].replace(
                        '$hash', ahash
                    )
                    logger.debug("Replacing $hash with %s", ahash)

                if (
                    '$' in new_action['value']
                    and '$session' not in new_action['value']
                ):
                    logger.debug(
                        "The capability has an action with an undefined parameter."
                        "It will be ignored"
                    )
                    logger.debug('new_action = %s', new_action)
                    return []

                if (
                    action['type'] == 'metasploit'
                    and capability.subclass == 'remote_code_execution'
                ) or (
                    'ssh/ssh_login' in action.get('value', '')
                ):
                    payload = self.get_payload(host)
                    new_action['value'] = "{} payload={}".format(
                        new_action['value'], payload
                    )

                final_actions.append(new_action)

        return final_actions

    def get_payload(self, host):
        """Given a host, determine which Metasploit payload to use when exploiting it
        Arguments:
            host(string): The host to get the payload for
        Returns:
            payload(string): The Metasploit payload to use for the host
        """
        try:
            host_cpe = self.host_capabilities[host].get('cpe', '?/?/?')
        except:
            logger.error("Host doesn't have CPE: %s", host)
            logger.error(self.host_capabilities)
        host_os, _, host_arch = host_cpe.split('/')

        # Set empty payload
        payload = ''
        if host_os == 'W':
            if host_arch == '32':
                payload = config.get(
                    'METASPLOIT',
                    'w32payload',
                    fallback='windows/meterpreter/bind_tcp',
                )
            if host_arch == '64':
                payload = config.get(
                    'METASPLOIT',
                    'w64payload',
                    fallback='windows/meterpreter/bind_tcp',
                )
        elif host_os == 'L':
            if host_arch == '32':
                payload = config.get(
                    'METASPLOIT',
                    'l32payload',
                    fallback='linux/x86/meterpreter/bind_tcp',
                )
            if host_arch == '64':
                payload = config.get(
                    'METASPLOIT',
                    'l64payload',
                    fallback='linux/x64/meterpreter/bind_tcp',
                )
        return payload

    @classmethod
    def get_parameter_dict(cls, action_value):
        """Given a string of metasploit parameters, parse and return a dictionary of values.
        Arguments:
            action_value(str): metasploit parameters in the format "name1=value1 name2=value2 ..."
            For example: "module=exploit/windows/smb/ms17_010_psexec rhosts=$target_host lport=4444"
        Returns:
            dict: name value pair of the parameters
            For example: { 'module': 'exploit/windows/smb/ms17_010_psexec',
                           'rhosts': '$target_host',
                'lport': '4444' }
        """
        parameters = {}

        action_value_list = action_value.split(' ')

        for action_value_item in action_value_list:
            if '=' in action_value_item:
                name, value = action_value_item.split('=')
                parameters[name] = value

        return parameters

    def resolve_capability_action(
        self, capability, values=None, resolved_actions=None
    ):
        """Populate parameters in capability actions and passes from child to parent capabilities
        Arguments:
            capability(Capability): The capability to resolve parameters for
            values(dict): A dictionary of parameter names and values
            resolved_actions(list): A list of actions with parameters populated
        Returns:
            resolvedActions(list): This list of actions with parameters populated
        """

        if values is None:
            values = {}

        if resolved_actions is None:
            resolved_actions = []
        logger.debug(
            "Resolving actions for capability: %s:%s (Values = %s)",
            capability.subclass,
            capability.cves,
            values,
        )

        for action in capability.actions:
            resolved_action = copy.deepcopy(action)
            if resolved_action['type'] == 'capability':
                parameters = Planner.get_parameter_dict(
                    resolved_action['value']
                )

                for p_name, p_value in parameters.items():
                    values[p_name] = p_value
                if capability.capability_class == 'service':
                    for l_capability in self.capabilities.keys():
                        if (
                            self.capabilities[l_capability].subclass
                            == capability.preconditions[0]['value']
                        ):
                            parent_capability = self.capabilities[l_capability]
                            break
                    try:
                        self.resolve_capability_action(
                            parent_capability, values, resolved_actions
                        )
                    except:
                        pass
            else:
                parameters = Planner.get_parameter_dict(
                    resolved_action['value']
                )

                for p_name, p_value in parameters.items():
                    if p_value.startswith('$') and p_name in values.keys():
                        resolved_action['value'] = resolved_action[
                            'value'
                        ].replace(p_value, values[p_name])
                resolved_actions.append(resolved_action)

        return resolved_actions

    def update_status(self, status):
        """Update current status with the given state
        Arguments:
            status(string): The status to add
        """
        if self.is_derived(status):
            for status_part in status.split('.'):
                logger.debug("Adding %s to current status", status_part)
                self.state.current_status.add(status_part)
        else:
            logger.debug("Adding %s to current status", status)
            self.state.current_status.add(status)

    def set_post_conditions(self, target_host, capability_id):
        """Sets the post conditions for the supplied capability for the target host in state
        Arguments:
            target_host(str): The host for which the capability is being used
            capability(Capability): A list of actions with parameters populated
        Modifies: state(State): Updated per capability postconditions
        Returns: None
        """

        logger.debug(
            "Setting post-conditions for capability: %s", capability_id
        )

        postconditions = self.capabilities[capability_id].postconditions

        self.update_status(capability_id)

        for condition in postconditions:
            condition_type = condition['type']
            condition_key = condition['key']
            condition_value = condition['value']
            logger.debug(
                "Setting post-condition Type: %s, Key: %s, Value: %s",
                condition_type,
                condition_key,
                condition_value,
            )
            # Currently the only postconditions are updating state
            if condition_type == 'state':
                if condition_key == 'current_status':
                    self.update_status(condition_value)
                elif condition_key == 'current_access':
                    self.state.current_access = AccessClass[
                        condition_value.upper()
                    ]
                elif condition_key == 'current_role':
                    if condition_value == '$role':
                        role = self.state.temp['role']
                        self.state.current_role = UserRole[role.upper()]
                    else:
                        self.state.current_role = UserRole[
                            condition_value.upper()
                        ]
                elif condition_key == 'current_host':
                    if condition_value == '$target_host':
                        self.state.current_host = target_host
                    else:
                        self.state.current_host = condition_value
                elif condition_key == 'add_credential_pwd':
                    username, password = condition_value.split(',')
                    self.state.add_credential(
                        target_host, condition_key, username, password
                    )
                elif condition_key == 'add_credential_hash':
                    self.state.add_credential(
                        target_host,
                        condition_key,
                        credential_hash=condition_value,
                    )

        # If the capability is derived, recurse and set post conditions for parent capabilities
        if self.is_derived(capability_id):
            self.set_post_conditions(
                target_host, self.get_parent_capability_id(capability_id)
            )

    def get_sensitive_states(self):
        """Load sensitive state information from configuration file
        Arguments: None
        Modifies: self.sensitives(dict): A global dictionary of state name, type, key and value
        Returns: None
        """
        for sensitive_item in config.options('SENSITIVE'):
            logger.debug('sensitive_item: %s', sensitive_item)
            new_sensitive = ast.literal_eval(
                config.get('SENSITIVE', sensitive_item)
            )
            self.sensitives.append(new_sensitive)

    def set_goals(self):
        """Load goal state information from configuration file
        Arguments: None
        Modifies: self.goals(dict): A global dictionary of goal name, type, key and value
        Returns: None
        """
        logger.debug("Setting Goal States")
        for goal_item in config.options('GOALS'):
            new_goal = ast.literal_eval(config.get('GOALS', goal_item))
            new_goal['id'] = goal_item
            self.goals.append(new_goal)

    def sort_attack_trees(self):
        self.attack_trees = sorted(
            self.attack_trees,
            key=lambda i: i['score']['combined'],
            reverse=True,
        )

    def run_single(self, target):
        """Runs Planning functions for single host mode
        Arguments:
            host(str): the host to find vulnerabilities
        """
        self.find_all_vulns(target)
        self.sort_attack_trees()

    def run_system(self, planner_goal, initial_host=None):
        """Runs Planning functions for system mode"""
        if 'INITIAL CONDITIONS' not in config.sections():
            logger.error(
                'INITIAL CONDITIONS not set: Could not perform planning.'
            )
            logger.error(
                'See example settings in the configuration file: %s',
                get_config_filename(),
            )
            sys.exit()

        if 'GOALS' not in config.sections():
            logger.error('GOALS not set: Could not perform planning.')
            logger.error(
                'See example settings in the configuration file: %s',
                get_config_filename(),
            )
            sys.exit()

        # Set initial state from configuration file
        self.set_initial_state(initial_host=initial_host)

        # If a GOAL (end condition) was specified on the command line, use that,
        # otherwise set from the configuration file
        if 'key' in planner_goal.keys():
            self.goals.append(planner_goal)
        else:
            self.set_goals()

        logger.info("Calculating Attack Paths")
        self.find_all_paths()
        self.sort_attack_trees()
