#!/usr/bin/python3
#
#  Copyright (C) 2018-2021 Toshiba Corporation and Peraton Labs, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

""" This module parses various input file types.
    - Network XML: read into a networkx data structure
    - Nessus: convert to common format
    - Nmap: convert to common format
    - Common: read into internal structure
    - Capabilities database: combine with above to internally
      represent network, services and vulnerabilities
"""

import logging
import csv
import re
import os
import xml.etree.ElementTree as ET
import networkx as nx

from .types import CapabilityRank, CapabilitySeverity, Capability
from .database import Database
from .config import config
from .metasploitdb import MetasploitDB

logger = logging.getLogger(__name__)


####################
# Helper Functions #
####################

TRUTH_VALUES = {'True', 'true', 1, '1'}


def _collapse_severity(severity):
    """Reduce any severity level greater than 3 (high) to high
    Arguments:
        severity (int): The severity of a capability
    Returns:
        int: severity value of 'high' or less
    """
    severity = min(severity, CapabilitySeverity.HIGH.value)

    return severity


##########################################


class Analyzer:
    """The Analyzer class imports data from various input files, classifies and builds any
    new capabilites, associates capabilities with hosts, and interacts with the
    database.
    """

    def __init__(self, execute, plan, datafile=None, netfile=None):
        """Initializes Analyzer class attributes, makes connections to the database and
        Metasploit DB / API.  Ensures configuration is correct and connections are
        ready.
        """
        self.plan = plan
        self.execute = execute

        self.capabilities = {}
        self.host_capabilities = {}
        self.network_graph = nx.Graph()
        self.vuln_scan_data_file = datafile
        self.network_rep = netfile
        self.scan_plugin = None
        self.unknown_services = {}

        self.database = Database()

        if not self._get_config_options() or not self.database.ready():
            self.valid = False
        else:
            self.valid = True
            self._get_capabilities_from_database()

    def ip_to_hostname(self, target):
        """Given a target IP address returns the associated hostname. If the target is
           not in the hosts database, simply return it.
        Arguments:
            target (string): The target IP address to look up
        Returns:
            target (string): The hostname for the target IP address
        """
        if target not in self.host_capabilities.keys():
            for host, host_details in self.host_capabilities.items():
                if target in [
                    interface[0] for interface in host_details['interfaces']
                ]:
                    logger.debug(
                        "IP address %s resolved to host %s", target, host
                    )
                    target = host

        return target.upper()

    def _get_config_options(self):
        """Read in default datafile and network representation from configuration if not
           specified on command line.
        Returns:
           (bool): True if configuration was able to be read, False if not.
        """
        try:
            if self.vuln_scan_data_file is None:
                self.vuln_scan_data_file = config.get(
                    'INPUT', 'default_datafile'
                )
            logger.info('Using datafile: %s', self.vuln_scan_data_file)

            if self.plan and self.network_rep is None:
                self.network_rep = config.get('INPUT', 'default_netfile')
        except Exception as exception:
            logger.error("Error Reading Configuration File: %s", exception)
            return False

        return True

    def _add_capabilities_to_host(self, host, capability_names):
        """Associate capabilities with a host
        Arguments:
            host (string): The host to associate capabilities with
            capability_names (list of strings): The capabilities to associate with
            the host.
        """
        host = self.ip_to_hostname(host)

        for capability_name in capability_names:
            capability = self.capabilities.get(capability_name, None)
            if capability is None:
                logger.error('Could not find capability %s', capability_name)
            elif capability.capability_class == 'banned':
                logger.debug('Banned from DB, capability %s', capability_name)
            elif (
                capability_name
                not in self.host_capabilities[host]['capabilities']
            ):
                self.host_capabilities[host]['capabilities'].append(
                    capability_name
                )
                logger.debug(
                    "Associated capability %s with %s", capability_name, host
                )

    def run(self):
        """Runs Analysis functions including converting and saving scan data file if necessary
            Reports a summary of capabilities detected
        Returns (bool): Success or Failure
        """
        self._detect_plugin_type()

        if self.plan:
            logger.info("Parsing Network Representation Using Internal Plugin")
            self._parse_network_xml(self.network_rep)

        if self.scan_plugin == 'nessus':
            logger.info("Parsing Nessus Results")
            common_dict_list = self._parse_convert_nessus()
            self._write_common_csv(common_dict_list, 'nessus')
        elif self.scan_plugin == 'common':
            logger.info("Parsing Common Format Results")
            common_dict_list = self._parse_common_csv()
        elif self.scan_plugin == 'nmap':
            logger.info("Parsing Nmap Format Results")
            common_dict_list = self._parse_convert_nmap()
            self._write_common_csv(common_dict_list, 'nmap')
        else:
            logger.error("Unsupported Scan Plugin: %s", self.scan_plugin)
            return 0

        logger.debug("Host DB: %s", self.host_capabilities)

        if not self._read_common(common_dict_list):
            return 0

        self._report_capabilities()

        return 1

    def _detect_plugin_type(self):
        """Detect which scan type (Nessus, Nmap or Common) the datafile is and
        set the scan plugin to use appropriately
        """
        self.scan_plugin = 'unknown'
        # Determine the plugin type
        with open(self.vuln_scan_data_file, 'r') as datafile:
            data = datafile.read()
            if 'NessusClientData' in data:
                self.scan_plugin = 'nessus'
            elif '"hostname","hostip","hostcpe","protocol"' in data:
                self.scan_plugin = 'common'
            elif 'DOCTYPE nmaprun' in data:
                self.scan_plugin = 'nmap'
            else:
                self.scan_plugin = 'unknown'
        logger.info('Detected scan type: %s', self.scan_plugin)

    def _parse_network_xml(self, nxmlfile):
        """Parse the proprietary network representation file to build the hosts database and
           internal network graph
        Arguments:
            nxmlfile (string): The filename of the network representation xml file.
        """
        tree = ET.parse(nxmlfile)
        root = tree.getroot()

        hosts = root.findall("hosts/host")
        connections = root.findall("connections/connection")

        for host in hosts:
            node_id = host.attrib['id'].upper()
            logger.debug('host.node_id=%s', node_id)
            node_passive = host.attrib['passive'] in TRUTH_VALUES
            if (
                node_id not in self.host_capabilities.keys()
                and not node_passive
            ):
                self.host_capabilities[node_id] = {
                    'interfaces': set(),
                    'capabilities': [],
                    'cpe': '',
                }
            if node_passive:
                self.network_graph.add_node(
                    node_id,
                    node_id=node_id,
                    node_passive=node_passive,
                    nodeType="switch",
                )
            else:
                self.network_graph.add_node(
                    node_id,
                    node_id=node_id,
                    node_passive=node_passive,
                    nodeType="host",
                )
            interfaces = host.findall("interfaces/interface")
            for interface in interfaces:
                interface_id = interface.attrib['id'].upper()
                interface_ip = interface.attrib['ip']
                interface_mac = interface.attrib['mac']
                logger.debug(
                    '    interface=%s %s %s',
                    interface_id,
                    interface_ip,
                    interface_mac,
                )
                self.host_capabilities[node_id]['interfaces'].add(
                    (interface_ip, interface_mac)
                )
                self.network_graph.add_node(
                    interface_id,
                    node_id=interface_ip,
                    node_passive=True,
                    nodeType="interface",
                )
                self.network_graph.add_edge(
                    node_id, interface_id, route=False, weight=1, length=0.5
                )
            routes = host.findall("routes/route")
            for route in routes:
                src_id = route.attrib['src_id'].upper()
                dst_id = route.attrib['dst_id'].upper()
                logger.debug('    route=%s %s', src_id, dst_id)
                self.network_graph.add_edge(
                    src_id, dst_id, route=True, weight=1, length=2
                )

        for connection in connections:
            start_node = connection.attrib['begin'].upper()
            end_node = connection.attrib['end'].upper()
            self.network_graph.add_edge(
                start_node, end_node, route=False, weight=1, length=4
            )
            logger.debug('connection: start=%s, end=%s', start_node, end_node)

        logger.debug('nodes=%s', self.network_graph.nodes)
        logger.debug('edges=%s', self.network_graph.edges)

    def write_capability_to_database(self, capability):
        """Write a new capability into the database
        Arguments:
            capability (Capability class): The full capability to write to the database
        """
        self.database.insert_capability(capability)

        for precondition in capability.preconditions:
            self.database.insert_precondition(
                capability.capability_id, precondition
            )

        for action in capability.actions:
            self.database.insert_action(capability.capability_id, action)

        for postcondition in capability.postconditions:
            self.database.insert_postcondition(
                capability.capability_id, postcondition
            )

    def _get_capabilities_from_database(self):
        """Reads capabilities from the database into memory"""
        capabilities = self.database.get_capabilities()

        for capability in capabilities:
            (
                capability_id,
                capability_title,
                capability_class,
                capability_subclass,
                capability_severity,
                capability_cvss,
                capability_rank,
                capability_solution,
                capability_cves,
            ) = capability

            # Obtain PAP fields
            preconditions = self._query_preconditions(capability_id)
            actions = self._query_actions(capability_id)
            postconditions = self._query_postconditions(capability_id)

            self._add_capability(
                capability_id,
                capability_title,
                capability_class,
                capability_subclass,
                capability_severity,
                capability_cves,
                capability_cvss,
                preconditions,
                actions,
                postconditions,
                rank=capability_rank,
                solution=capability_solution,
            )

        logger.info("Loaded %d capabilities from database", len(capabilities))

    def _query_postconditions(self, capability_id):
        postconditions = []
        db_postconditions = self.database.get_postconditions(capability_id)
        for postcondition in db_postconditions:
            (_, ptype, pkey, pvalue) = postcondition
            ipostcondition = {'type': ptype, 'key': pkey, 'value': pvalue}
            postconditions.append(ipostcondition)
        return postconditions

    def _query_actions(self, capability_id):
        actions = []
        db_actions = self.database.get_actions(capability_id)
        for action in db_actions:
            (_, atype, akey, avalue) = action
            iaction = {'type': atype, 'key': akey, 'value': avalue}
            actions.append(iaction)
        return actions

    def _query_preconditions(self, capability_id):
        preconditions = []
        db_preconditions = self.database.get_preconditions(capability_id)
        for precondition in db_preconditions:
            (phost, ptype, pkey, pvalue) = precondition
            iprecondition = {
                'host': phost,
                'type': ptype,
                'key': pkey,
                'value': pvalue,
            }
            preconditions.append(iprecondition)
        return preconditions

    def _add_capability(
        self,
        capability_id,
        ctitle,
        cclass,
        csubclass,
        cseverity,
        ccves,
        ccvss,
        precons,
        actions,
        postcons,
        rank,
        solution,
        write_db=False,
    ):
        """Adds a capability to the in-memory list and optionally writes to the database
        Arguments:
            capability_id, ctitle, cclass, csubclass, cseverity, ccves, ccvss, prcons, actions
            postcons, rank, solution (strings): Capability attributes
            write_db (bool): Whether to write the capability to the database or not
        """
        if capability_id not in self.capabilities.keys():
            new_capability = Capability(
                capability_id,
                ctitle,
                cclass,
                csubclass,
                cseverity,
                ccves,
                ccvss,
                precons,
                actions,
                postcons,
                rank=rank,
                solution=solution,
            )
            self.capabilities[capability_id] = new_capability

            if write_db:
                logger.info("Adding New Capability to Database: %s", ctitle)
                self.write_capability_to_database(new_capability)

    def _match_service_capability(self, protocol, port):
        """Given a protocol and port, attempt to retrieve known service capabilities
            which utilize them.
        Arguments:
            protocol (string): The protocol detected in the scan data ('TCP' or 'UDP')
            port (int): The port detected in the scan data
        Returns:
            matched_capabilities (list of strings): The names of the matched capabilities.
        """
        # If the port is '0' we can't match it
        if port == '0':
            return []
        matched_capabilities = []
        protocol_port = "{}/{}".format(protocol.lower(), port)
        for capability_name, capability in self.capabilities.items():
            if capability.capability_class == 'service':
                for condition in capability.preconditions:
                    if (
                        condition['type'] == 'service'
                        and condition['value'] == protocol_port
                    ):
                        logger.debug(
                            "Matched %s for %s/%s",
                            capability_name,
                            protocol,
                            port,
                        )
                        matched_capabilities.append(capability_name)
                    elif condition['type'] == 'capability':
                        cap_split = '.'.join(capability_name.split('.')[:-1])
                        if cap_split in matched_capabilities:
                            matched_capabilities.append(capability_name)

        return matched_capabilities

    def _add_metasploit_capability(
        self,
        host_name,
        severity,
        cvss,
        cclass,
        rank,
        name_or_module,
        protocol,
        port,
        solution,
    ):
        """Build and add a new exploit (metasploit) capability as well as associate it
            with the host the vulnerability was detected on.
        Arguments:
            host_name (string): The host the vulnerability was detected on
            severity (string): The severity reported in the scan data
            cvss (string): CVSS information if available
            cclass (string): Exploit class (RCE or PE)
            rank (string): Metasploit module rank
            name_or_module (string): Metasploit "long" name or module name
            protocol (string): The protocol the exploitable service utilizes
            port (string): The port the exploitable service listens on
            solution (string): The solution suggested in the scan data
        Returns:
            (bool): Success (True) or Failure (False)
        """
        # Assume the module is provided and look up the name
        module = name_or_module
        name = MetasploitDB.get_name_by_module(module)

        # If the module is unknown, assume the name was provided
        if not name:
            # The name was provided, look up module name
            name = name_or_module
            module = MetasploitDB.get_module_by_name(name_or_module)

        logger.debug('module = %s, name = %s', module, name)

        cves = ','.join(MetasploitDB.get_cvelist_by_name(name))

        if module == 'Unknown':
            logger.error(
                "Metasploit name '%s' for host %s not found in Metasploit DB cache.\
                          This could be due to a mismatch between Metasploit name in scan data\
                          and Metasploit name in the current version of the Metasploit DB.\
                          Consider updating Metasploit DB cache.",
                name,
                host_name,
            )
            return False

        metasploit_options = MetasploitDB.get_options_by_module(module)

        actual_options = self._fix_metasploit_options(metasploit_options)

        actions = [
            {
                "type": "metasploit",
                "key": cclass,
                "value": "module={} {}".format(module, actual_options),
            }
        ]
        template_capability = self.capabilities[cclass]
        for condition in template_capability.preconditions:
            if condition['type'] == 'service':
                condition['value'] = '{}/{}'.format(protocol, port)
        self._add_capability(
            module,
            name,
            "exploit",
            cclass,
            severity,
            cves,
            cvss,
            template_capability.preconditions,
            actions,
            template_capability.postconditions,
            rank,
            solution,
            write_db=True,
        )
        self._add_capabilities_to_host(host_name, [module])

        return True

    def _add_service_capability(self, host_name, protocol, port):
        """Match capabilities based on detected protocol and port.
            Associate the matched capabilities with the host they
            were detected on.
        Arguments:
            host_name (string): The host the service was detected on
            protocol (string): The protocol the service utilizes
            port (string): The port the service listens on
        Returns:
            (bool): Success (True)
        """
        matched_capabilities = self._match_service_capability(protocol, port)

        if matched_capabilities:
            self._add_capabilities_to_host(host_name, matched_capabilities)
        else:
            protocol_port = "{}/{}".format(protocol.lower(), port)
            if protocol_port in self.unknown_services.keys():
                self.unknown_services[protocol_port].add(host_name)
            else:
                self.unknown_services[protocol_port] = {host_name}

        return True

    def _parse_default(self, host_name, host_ip, host_cpe):
        """This function performs basic tasks required for all scan data types
            such as adding detected host information to the hosts database.
        Arguments:
            host_name (string): The host name (or IP address if no host name was determined)
            host_ip (string): The hosts IP address
            host_cpe (string): Information about the host platform (OS, architecture, etc.)
        """
        logger.debug("Examining results for host: %s", host_name)
        if host_name in self.host_capabilities.keys():
            self.host_capabilities[host_name]['interfaces'].add((host_ip, ''))
            if not self.host_capabilities[host_name]['cpe']:
                self.host_capabilities[host_name]['cpe'] = host_cpe
        else:
            self.host_capabilities[host_name] = {
                'interfaces': {(host_ip, '')},
                'cpe': host_cpe,
                'capabilities': [],
            }

    def _parse_common_csv(self):
        """This function simply loads a common format csv file into a
            Python data structure.
        Returns:
            common_dict_list (list of dictionaries): The common format scan data
        """
        common_dict_list = []
        with open(self.vuln_scan_data_file, 'r', newline='') as csvfile:
            reader = csv.DictReader(csvfile)
            for row in reader:
                common_dict_list.append(dict(row))

        return common_dict_list

    def _write_common_csv(self, common_dict_list, input_type):
        """Writes converted common format file to disk
        Arguments:
            common_dict_list (list of dictionaries): Common format scan data
            input_type (string): The original scan data input format
        """
        output_file_path, old_file_name = os.path.split(self.vuln_scan_data_file)
        filename = "{}/{}_{}_{}.common".format(
            output_file_path, old_file_name.split('.')[0], input_type, 'converted'
        )
        logger.info(
            "Writing converted %s input file to: %s", input_type, filename
        )
        with open(filename, 'w', newline='') as csvfile:
            fieldnames = list(common_dict_list[0].keys())
            writer = csv.DictWriter(
                csvfile, fieldnames=fieldnames, quoting=csv.QUOTE_ALL
            )
            writer.writeheader()
            for item in common_dict_list:
                writer.writerow(item)

    def _read_common(self, common_dict_list):
        """Parses the common format information and adds listed capabilities
            to in memory list of capabilities and associates with hosts.
        Arguments:
            common_dict_list (list of dictionaries): Common format scan data
        Returns:
            (bool): Success (True) or Failure (False)
        """
        for item in common_dict_list:
            host_name = item['hostname'].upper()
            host_ip = item['hostip']
            host_cpe = item['hostcpe']
            name = item['name']
            solution = item['solution']
            protocol = item['protocol']
            port = item['port']
            item_type = item['type']
            item_class = item['class']
            severity = item['severity']
            cvss = item['cvss']
            rank = item['rank']

            if not host_name:
                host_name = host_ip

            self._parse_default(host_name, host_ip, host_cpe)

            if item_type == 'service':
                if not self._add_service_capability(host_name, protocol, port):
                    return False
            elif item_type == 'exploit':
                if not self._add_metasploit_capability(
                    host_name,
                    severity,
                    cvss,
                    item_class,
                    rank,
                    name,
                    protocol,
                    port,
                    solution,
                ):
                    return False

        return True

    def build_common_service(
        self,
        host_name,
        host_ip,
        host_cpe,
        protocol,
        port,
        service_name,
        common_out,
    ):
        """Builds common format service capabilities based on information detected in other
            scan data formats.
        Arguments:
            host_name (string): The host name
            host_ip (string): The host's IP address
            host_cpe (string): The host CPE information
            protocol (string): The protocol the service uses
            port (string): The port the service runs on
            service_name (string): The name of the service
            common_out (list of dictionaries): The current list of common formated capabilities
        Returns:
            common_out (list of dictionaries): The list with the new service capabilities added
        """
        matched_capabilities = self._match_service_capability(protocol, port)

        if not matched_capabilities:
            if not self._check_duplicate_common_entry(
                common_out, host_name, protocol=protocol, port=port
            ):
                common_entry = {
                    "hostname": host_name,
                    "hostip": host_ip,
                    "hostcpe": host_cpe,
                    "protocol": protocol,
                    "port": port,
                    "type": "service",
                    "name": service_name,
                    "class": service_name,
                    "rank": CapabilityRank.NORMAL.value,
                    "severity": CapabilitySeverity.NONE.value,
                    "cvss": "",
                    "solution": "Ensure this service is properly secured.",
                }
                common_out.insert(0, common_entry)
        else:
            for capability in matched_capabilities:
                capability = capability.split('.')[0]
                capability_instance = self.capabilities[capability]
                if capability_instance.capability_class == 'service':
                    service_name = capability_instance.title
                    if not self._check_duplicate_common_entry(
                        common_out, host_name, protocol=protocol, port=port
                    ):
                        common_entry = {
                            "hostname": host_name,
                            "hostip": host_ip,
                            "hostcpe": host_cpe,
                            "protocol": protocol,
                            "port": port,
                            "type": "service",
                            "name": service_name,
                            "class": capability_instance.subclass,
                            "rank": capability_instance.rank,
                            "severity": capability_instance.severity,
                            "cvss": capability_instance.cvss,
                            "solution": capability_instance.solution,
                        }
                        logger.debug("Adding common service: %s", common_entry)
                        common_out.insert(0, common_entry)

        return common_out

    def build_common_exploit(
        self,
        host_name,
        host_ip,
        host_cpe,
        protocol,
        port,
        metasploit_name,
        description,
        cvss,
        severity,
        solution,
        common_out,
    ):
        """Classifies and builds common format exploit capabilities based on information
            detected in other scan data formats.
        Arguments:
            host_name (string): The host name
            host_ip (string): The host's IP address
            host_cpe (string): The host CPE information
            protocol (string): The protocol the exploitable service uses
            port (string): The port the exploitable service runs on
            metasploit_name (string): The metasploit name for the exploit
            description (string): Description information provided in the scan data
            cvss (string): CVSS information provided in the scan data
            severity (string): Severity information provided in the scan data
            solution (string): Solution information provided in the scan data
            common_out (list of dictionaries): The current list of common formated capabilities
        Returns:
            common_out (list of dictionaries): The list with the new exploit capability added
        """
        metasploit_module = MetasploitDB.get_module_by_name(metasploit_name)
        if not self._check_duplicate_common_entry(
            common_out, host_name, name=metasploit_module
        ):
            metasploit_info = self._classify_vulnerability(
                metasploit_name, description, cvss, port
            )
            if not metasploit_info:
                return common_out
            exploit_class = metasploit_info['class']
            rank = metasploit_info['rank'].lower()
            template_capability = self.capabilities[exploit_class]
            if not solution:
                solution = template_capability.solution
            if metasploit_info:
                common_entry = {
                    "hostname": host_name,
                    "hostip": host_ip,
                    "hostcpe": host_cpe,
                    "protocol": protocol,
                    "port": port,
                    "type": "exploit",
                    "name": metasploit_module,
                    "class": exploit_class,
                    "rank": rank,
                    "severity": severity,
                    "cvss": cvss,
                    "solution": solution,
                }
                common_out.append(common_entry)

        return common_out

    @classmethod
    def _check_duplicate_common_entry(
        cls, common_out, host_name, protocol=None, port=None, name=None
    ):
        """Checks to ensure we don't attempt to add duplicate common format entries for any
            particular host.
        Arguments:
            common_out (list of dictionaries): The current list of common formated capabilities
            host_name (string): The host name
            protocol (string): For services, the protocol used by the service
            port (string): For services, the port the service listens on
            name (string): For exploits, the name of the Metasploit module
        Returns:
            (bool): True indicates a duplicate entry exists.  False indicates no duplicates.
        """
        for item in common_out:
            if item['hostname'] == host_name:
                # This should ensure no duplicate exploits exist
                if name is not None and item['name'] == name:
                    return True
                # This should ensure no duplicate services exist
                if (
                    name is None
                    and item['protocol'] == protocol
                    and item['port'] == port
                ):
                    return True

        return False

    def _parse_convert_nessus(self):
        """Loads, parses and converts Nessus formated scan data to common format
        Returns:
            common_out(list of dictionaries): The converted common formated scan data
        """
        logger.info("Converting nessus input file to common format input file")
        tree = ET.parse(self.vuln_scan_data_file)
        root = tree.getroot()
        common_out = []

        for report_host in root.findall('./Report/ReportHost'):
            host_name = report_host.attrib['name'].upper()
            host_ip = 'None'
            host_os = host_variation = host_arch = '?'

            for tag in report_host.findall('HostProperties/tag'):
                host_property = tag.attrib['name']
                if host_property == 'host-ip':
                    host_ip = tag.text
                if 'cpe' in host_property:
                    if 'microsoft' in tag.text.lower():
                        host_os = 'W'
                        if 'windows_xp' in tag.text.lower():
                            host_variation = 'XP'
                        elif 'windows_7' in tag.text.lower():
                            host_variation = '7'
                        elif 'windows_vista' in tag.text.lower():
                            host_variation = 'V'
                        elif 'windows_10' in tag.text.lower():
                            host_variation = '10'
                    elif 'linux' in tag.text.lower():
                        host_os = 'L'
                        host_arch = '64'
                        if 'ubuntu' in tag.text.lower():
                            host_variation = 'UB'
                    if 'x86' in tag.text.lower():
                        host_arch = '32'
                    elif 'x64' in tag.text.lower():
                        host_arch = '64'

                elif host_property == 'netbios-name':
                    host_name = tag.text.upper()
                elif host_property == 'hostname' and tag.text != '(none)':
                    host_name = tag.text.upper()

            # If hostname was only in the report as an IP address,
            # attempt to match it with a hostname
            host_name = self.ip_to_hostname(host_name)

            if host_arch == '?':
                for report_item in report_host.findall('ReportItem'):
                    for plugin_output in report_item.findall('plugin_output'):
                        output_text = plugin_output.text.lower()
                        if 'x64' in output_text:
                            host_arch = '64'
                        if 'x86' in output_text and host_arch == '?':
                            host_arch = '32'

            host_cpe = "{}/{}/{}".format(host_os, host_variation, host_arch)
            logger.debug("Host: %s, CPE: %s", host_name, host_cpe)

            for report_item in report_host.findall('ReportItem'):
                protocol = report_item.attrib['protocol'].lower()
                port = report_item.attrib['port']
                name = report_item.attrib['svc_name'].lower()
                severity = CapabilitySeverity(
                    _collapse_severity(int(report_item.attrib['severity']))
                ).name
                if port != '0':
                    common_out = self.build_common_service(
                        host_name,
                        host_ip,
                        host_cpe,
                        protocol,
                        port,
                        name,
                        common_out,
                    )

                # Check if this is an exploit with a metasploit module
                metasploit_name_element = report_item.find("metasploit_name")

                if metasploit_name_element is not None:
                    solution = report_item.find("solution").text
                    solution = solution.replace('\n', ' ')
                    description = report_item.find("description").text.lower()
                    try:
                        cvss = report_item.find("cvss3_vector").text
                    except:
                        try:
                            cvss = report_item.find("cvss_vector").text
                        except:
                            cvss = ""

                    metasploit_nessus_name = metasploit_name_element.text
                    related_names = MetasploitDB.get_related_names_by_name(
                        metasploit_nessus_name
                    )
                    for metasploit_name in related_names:
                        common_out = self.build_common_exploit(
                            host_name,
                            host_ip,
                            host_cpe,
                            protocol,
                            port,
                            metasploit_name,
                            description,
                            cvss,
                            severity,
                            solution,
                            common_out,
                        )

        return common_out

    def _parse_convert_nmap(self):
        """Loads, parses and converts Nmap formated scan data to common format
        Returns:
            common_out(list of dictionaries): The converted common formated scan data
        """
        logger.info("Converting nmap input file to common format input file")
        tree = ET.parse(self.vuln_scan_data_file)
        root = tree.getroot()
        common_out = []

        for host in root.findall('./host'):
            host_os = host_variation = host_arch = '?'
            host_name = 'None'
            host_ip = host.find('address').attrib['addr']
            for hostname in host.findall('hostnames/hostname'):
                host_name = hostname.attrib['name'].upper()

            for osclass in host.find('os/osmatch/osclass'):
                nmap_cpe = osclass.text.lower()
                if 'microsoft' in nmap_cpe:
                    host_os = 'W'
                    if 'windows_xp' in nmap_cpe:
                        host_variation = 'XP'
                    elif 'windows_7' in nmap_cpe:
                        host_variation = '7'
                    elif 'windows_vista' in nmap_cpe:
                        host_variation = 'V'
                    elif 'windows_10' in nmap_cpe:
                        host_variation = '10'
                elif 'linux' in nmap_cpe:
                    host_os = 'L'
                    host_arch = '64'
                    if 'ubuntu' in nmap_cpe:
                        host_variation = 'UB'

            host_cpe = "{}/{}/{}".format(host_os, host_variation, host_arch)

            for port in host.findall('ports/port'):
                state = port.find('state').attrib['state']
                if state != 'open':
                    continue
                protocol = port.attrib['protocol'].lower()
                portnumber = port.attrib['portid']
                try:
                    name = port.find('service').attrib['name']
                except:
                    name = ""
                if portnumber != '0':
                    common_out = self.build_common_service(
                        host_name,
                        host_ip,
                        host_cpe,
                        protocol,
                        portnumber,
                        name,
                        common_out,
                    )

            for script in host.findall('hostscript/script'):
                output = script.attrib['output'].lstrip().lower()
                if output.startswith('vulnerable'):
                    description = []
                    cve = ""
                    for table in script.findall('table'):
                        if table.attrib['key'].startswith('CVE-'):
                            cve = table.attrib['key']
                            for element in table.findall('elem'):
                                if element.attrib['key'] == 'title':
                                    description.append(element.text)
                            for inner_table in table.findall('table'):
                                if inner_table.attrib['key'] == 'description':
                                    for element in inner_table.findall('elem'):
                                        description.append(element.text)

                    if cve and description:
                        description = ' '.join(description)
                        cvss = ""
                        try:
                            risk_factor = re.findall(
                                r'risk factor: (high|critical|medium|low)&#xa;',
                                output,
                            )[0]
                            severity = CapabilitySeverity[
                                risk_factor.upper()
                            ].name
                        except:
                            logger.warning(
                                "NMAP Vulnerability %s has no risk rating, assuming 'high'",
                                cve,
                            )
                            severity = CapabilitySeverity.HIGH.name

                        related_names = MetasploitDB.get_related_names_by_cve(
                            cve
                        )

                        for metasploit_name in related_names:
                            common_out = self.build_common_exploit(
                                host_name,
                                host_ip,
                                host_cpe,
                                protocol,
                                portnumber,
                                metasploit_name,
                                description,
                                cvss,
                                severity,
                                "",
                                common_out,
                            )

        return common_out

    @classmethod
    def _classify_vulnerability(cls, name, description, cvss, port):
        """Attempts to classify a detected vulnerability as either remote code execution (RCE) or
           privilege escalation (PE)
        Arguments:
           name (string): Metasploit module name
           description (string): Vulnerability description from scan data
           cvss (string): CVSS information from scan data
           port (int): The port the vulnerability was detected on
        Returns:
           (dict) or (None): Information regarding the vulnerability's rank,
            targets and it's classification if it could be classified
        """
        rce_desc_match_strings = [
            r'.*(command|code) execution.*',
            r'.*arbitrary (code|command).*',
        ]
        rce_desc_nomatch_strings = [r'.*(implant|click).*', r'.*trick user.*']
        rce_cvss_match_regex = r'.*'
        rce_cvss_nomatch_regex = r'.*(UI:R|AV:L)/.*'

        pe_desc_match_strings = [
            '.*(elevation|escalation) of privilege.*',
            'privilege escalation',
        ]
        pe_desc_nomatch_strings = []
        pe_cvss_match_regex = r'.*AV:L/.*'
        pe_cvss_nomatch_regex = r'.*/UI:R/.*'

        metasploit_module_undesirables = '.*_check|auxiliary/dos.*'

        module = MetasploitDB.get_module_by_name(name)

        # Disregard modules which match the regex.  No check only modules and no denial of service.
        if re.match(metasploit_module_undesirables, module):
            return None

        metasploit_info = MetasploitDB.get_info_by_module(module)

        if metasploit_info:
            metasploit_options = MetasploitDB.get_options_by_module(module)
            parse_this = "{} {}".format(
                description.lower(), metasploit_info.description.lower()
            ).replace('\n', '')

            rce_match = False
            pe_match = False
            if (
                metasploit_info.module_type == 'exploit'
                and (
                    'RHOSTS' in metasploit_options.keys()
                    or 'RHOST' in metasploit_options.keys()
                )
                and 'cmd' not in metasploit_info.arch
            ):
                for rce_match_string in rce_desc_match_strings:
                    if (
                        re.match(rce_match_string, parse_this, re.IGNORECASE)
                        and re.match(rce_cvss_match_regex, cvss)
                        and not re.match(rce_cvss_nomatch_regex, cvss)
                    ):
                        rce_match = True
                        for rce_nomatch_string in rce_desc_nomatch_strings:
                            if re.match(
                                rce_nomatch_string, parse_this, re.IGNORECASE
                            ):
                                rce_match = False

                if rce_match:
                    if not port or port != '0':
                        logger.debug(
                            "Classified '%s' as Remote Code Execution", name
                        )
                        return {
                            'rank': metasploit_info.rank,
                            'targets': metasploit_info.targets,
                            'class': 'remote_code_execution',
                        }

            if (
                metasploit_info.module_type == 'post'
                or 'SESSION' in metasploit_options.keys()
            ) and not (
                'RHOSTS' in metasploit_options.keys()
                or 'RHOST' in metasploit_options.keys()
            ):
                for pe_match_string in pe_desc_match_strings:
                    if (
                        re.match(pe_match_string, parse_this, re.IGNORECASE)
                        and re.match(pe_cvss_match_regex, cvss)
                        and not re.match(pe_cvss_nomatch_regex, cvss)
                    ):
                        pe_match = True
                        for pe_nomatch_string in pe_desc_nomatch_strings:
                            if re.match(
                                pe_nomatch_string, parse_this, re.IGNORECASE
                            ):
                                pe_match = False

                if pe_match:
                    logger.debug(
                        "Classified '%s' as Privilege Escalation", name
                    )
                    return {
                        'rank': metasploit_info.rank,
                        'targets': metasploit_info.targets,
                        'class': 'privilege_escalation',
                    }

        return None

    def _report_capabilities(self):
        """Simply reports out details regarding each host and the capabilities detected on them"""
        for host, host_info in self.host_capabilities.items():
            host_exploits = []
            host_services = []
            for capability in host_info['capabilities']:
                if self.capabilities[capability].capability_class == 'exploit':
                    host_exploits.append(capability)
                else:
                    host_services.append(capability)
            if len(host_exploits) + len(host_services) > 0:
                logger.info(
                    "Capabilities detected on %s: %d (Exploits: %d, Services: %d)",
                    host,
                    len(host_exploits) + len(host_services),
                    len(host_exploits),
                    len(host_services),
                )
                if host_exploits:
                    logger.debug("\tExploits: %s", ', '.join(host_exploits))
                if host_services:
                    logger.debug("\tServices: %s", ', '.join(host_services))
            elif host != 'ATTACKER':
                logger.warning("Didn't detect ANY capabilities on %s", host)

        if len(self.unknown_services.keys()) > 0:
            logger.debug(
                "Unknown Services: %s", len(self.unknown_services.keys())
            )
            for service, service_info in self.unknown_services.items():
                logger.debug("\t%s on hosts %s", service, service_info)

    @classmethod
    def _fix_metasploit_options(cls, metasploit_options):
        """This function applies various modifications to metasploit options including:
           - inserting placeholders where certain values need to be replaced when
             populating when the capability action is inserted into an attack step (hop)
           - inserting certain hard coded values such as for lport and rport
        Arguments:
           metasploit_options (list of dictionaries): Metasploit options
        Returns:
           actual_options (list): The modified options to be used in the capability action
        """
        actual_options = []
        for option, value in metasploit_options.items():
            if value is not None and value != '':
                actual_options.append('{}={}'.format(option.lower(), value))
            elif option.lower() == 'rhost':
                actual_options.append('rhost=$target_host')
            elif option.lower() == 'lport':
                actual_options.append('lport=4444')
            elif option.lower() == 'rhosts':
                actual_options.append('rhosts=$target_host')
            elif option.lower() == 'httpusername':
                actual_options.append('HttpUsername=$username')
            elif option.lower() == 'username':
                actual_options.append('username=$username')
            elif option.lower() == 'password':
                actual_options.append('password=$password')
            elif option.lower() == 'httppassword':
                actual_options.append('HttpPassword=$password')
            elif option.lower() == 'session':
                pass
            else:
                logger.warning("Unsupported metasploit option: %s", option)
        actual_options = ' '.join(actual_options)

        return actual_options
