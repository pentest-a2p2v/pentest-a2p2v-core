#!/usr/bin/python3
# SPDX-License-Identifier: Apache-2.0
# SPDX-FileCopyrightText: Copyright 2018-2023 Toshiba Corporation and Peraton Labs, Inc.
# See README.md for license details

""" This module parses various input file types.
    - Network XML: read into a networkx data structure
    - Nessus: convert to common format
    - Nmap: convert to common format
    - Common: read into internal structure
    - Capabilities database: combine with above to internally
      represent network, services and vulnerabilities
"""

import logging
import csv
import re
import os
import xml.etree.ElementTree as ET
import networkx as nx

from .types import CapabilityRank, CapabilitySeverity, Capability
from .config import config
from .capabilitydb import Capabilitydb
from .metasploitpap import MetasploitPAP

logger = logging.getLogger(__name__)


####################
# Helper Functions #
####################

TRUTH_VALUES = {'True', 'true', 1, '1'}


def _collapse_severity(severity):
    """Reduce any severity level greater than 3 (high) to high
    Arguments:
        severity (int): The severity of a capability
    Returns:
        int: severity value of 'high' or less
    """
    severity = min(severity, CapabilitySeverity.HIGH.value)

    return severity


##########################################


class Analyzer:
    """The Analyzer class imports data from various input files, classifies and builds any
    new capabilites, associates capabilities with hosts, and interacts with the
    database.
    """

    def __init__(self, execute, plan, datafile=None, netfile=None):
        """Initializes Analyzer class attributes, makes connections to the database and
        Metasploit DB / API.  Ensures configuration is correct and connections are
        ready.
        """
        self.plan = plan
        self.execute = execute

        self.capabilities = {}
        self.host_capabilities = {}
        self.network_graph = nx.Graph()
        self.vuln_scan_data_file = datafile
        self.network_rep = netfile
        self.scan_plugin = None
        self.unknown_services = {}

        self.capabilitydb = Capabilitydb()
        self.metasploitpap = MetasploitPAP()
        self.available_capabilities = self.capabilitydb.capabilities
        self.capabilities_user = self.capabilitydb.capabilities_user 
        self._add_user_defined_capabilities()

        if not self._get_config_options():
            self.valid = False 
        else:
            self.valid = True         

    def ip_to_hostname(self, target):
        """Given a target IP address returns the associated hostname. If the target is
           not in the hosts database, simply return it.
        Arguments:
            target (string): The target IP address to look up
        Returns:
            target (string): The hostname for the target IP address
        """
        if target not in self.host_capabilities.keys():
            for host, host_details in self.host_capabilities.items():
                if target in [
                    interface[0] for interface in host_details['interfaces']
                ]:
                    logger.debug(
                        "IP address %s resolved to host %s", target, host
                    )
                    target = host

        return target.upper()

    def _get_config_options(self):
        """Read in default datafile and network representation from configuration if not
           specified on command line.
        Returns:
           (bool): True if configuration was able to be read, False if not.
        """
        try:
            if self.vuln_scan_data_file is None:
                self.vuln_scan_data_file = config.get(
                    'INPUT', 'default_datafile'
                )
            logger.info('Using datafile: %s', self.vuln_scan_data_file)

            if self.plan and self.network_rep is None:
                self.network_rep = config.get('INPUT', 'default_netfile')
        except Exception as exception:
            logger.error("Error Reading Configuration File: %s", exception)
            return False

        return True

    def _add_capabilities_to_host(self, host, capability_names):
        """Associate capabilities with a host
        Arguments:
            host (string): The host to associate capabilities with
            capability_names (list of strings): The capabilities to associate with
            the host.
        """
        host = self.ip_to_hostname(host)

        for capability_name in capability_names:
            capability = self.capabilities.get(capability_name, None)
            if capability is None:
                logger.error('Could not find capability %s', capability_name)
            elif capability.capability_class == 'banned':
                logger.debug('Banned from DB, capability %s', capability_name)
            elif (
                capability_name
                not in self.host_capabilities[host]['capabilities']
            ):
                self.host_capabilities[host]['capabilities'].append(
                    capability_name
                )
                logger.debug(
                    "Associated capability %s with %s", capability_name, host
                )

    def _add_user_defined_capabilities(self):
        """Add user defined capabilities to Capabilities in memory
        """
        for capability_id in self.capabilities_user.keys():
            if capability_id not in self.capabilities.keys():
                self.capabilities[capability_id] = self.capabilities_user[capability_id] 

    def run(self):
        """Runs Analysis functions including converting and saving scan data file if necessary
            Reports a summary of capabilities detected
        Returns (bool): Success or Failure
        """
        self._detect_plugin_type()

        if self.plan:
            logger.info("Parsing Network Representation Using Internal Plugin")
            self._parse_network_xml(self.network_rep)

        if self.scan_plugin == 'nessus':
            logger.info("Parsing Nessus Results")
            common2_out = self._parse_convert_nessus()
            self._write_common2_csv(common2_out, 'nessus')
            common_dict_list = self._parse_common2_csv('nessus')
            self._write_common_csv(common_dict_list, 'nessus')
        elif self.scan_plugin == 'common2':
            common_dict_list = self._parse_common2_csv('')
            self._write_common_csv(common_dict_list, 'common2')
        elif self.scan_plugin == 'common':
            logger.info("Parsing Common Format Results")
            common_dict_list = self._parse_common_csv()
        elif self.scan_plugin == 'nmap':
            logger.info("Parsing Nmap Format Results")
            common2_out = self._parse_convert_nmap()
            self._write_common2_csv(common2_out, 'nmap')
            common_dict_list = self._parse_common2_csv('nmap')
            self._write_common_csv(common_dict_list, 'nmap')
        else:
            logger.error("Unsupported Scan Plugin: %s", self.scan_plugin)
            return 0

        logger.debug("Host DB: %s", self.host_capabilities)

        if not self._read_common_capabilities(common_dict_list):
            return 0         

        self._report_capabilities()

        return 1

    def _detect_plugin_type(self):
        """Detect which scan type (Nessus, Nmap or Common) the datafile is and
        set the scan plugin to use appropriately
        """
        self.scan_plugin = 'unknown'
        # Determine the plugin type
        with open(self.vuln_scan_data_file, 'r') as datafile:
            data = datafile.read()
            if 'NessusClientData' in data:
                self.scan_plugin = 'nessus'
            elif '"hostname","hostip","hostcpe","protocol"' in data:
                if 'cves' in data:
                    self.scan_plugin = 'common2'
                else:
                    self.scan_plugin = 'common'
            elif 'DOCTYPE nmaprun' in data:
                self.scan_plugin = 'nmap'
            else:
                self.scan_plugin = 'unknown'
        logger.info('Detected scan type: %s', self.scan_plugin)

    def _parse_network_xml(self, nxmlfile):
        """Parse the proprietary network representation file to build the hosts database and
           internal network graph
        Arguments:
            nxmlfile (string): The filename of the network representation xml file.
        """
        tree = ET.parse(nxmlfile)
        root = tree.getroot()

        hosts = root.findall("hosts/host")
        connections = root.findall("connections/connection")

        for host in hosts:
            node_id = host.attrib['id'].upper()
            logger.debug('host.node_id=%s', node_id)
            node_passive = host.attrib['passive'] in TRUTH_VALUES
            if (
                node_id not in self.host_capabilities.keys()
                and not node_passive
            ):
                self.host_capabilities[node_id] = {
                    'interfaces': set(),
                    'capabilities': [],
                    'cpe': '',
                }
            if node_passive:
                self.network_graph.add_node(
                    node_id,
                    node_id=node_id,
                    node_passive=node_passive,
                    nodeType="switch",
                )
            else:
                self.network_graph.add_node(
                    node_id,
                    node_id=node_id,
                    node_passive=node_passive,
                    nodeType="host",
                )
            interfaces = host.findall("interfaces/interface")
            for interface in interfaces:
                interface_id = interface.attrib['id'].upper()
                interface_ip = interface.attrib['ip']
                interface_mac = interface.attrib['mac']
                logger.debug(
                    '    interface=%s %s %s',
                    interface_id,
                    interface_ip,
                    interface_mac,
                )
                self.host_capabilities[node_id]['interfaces'].add(
                    (interface_ip, interface_mac)
                )
                self.network_graph.add_node(
                    interface_id,
                    node_id=interface_ip,
                    node_passive=True,
                    nodeType="interface",
                )
                self.network_graph.add_edge(
                    node_id, interface_id, route=False, weight=1, length=0.5
                )
            routes = host.findall("routes/route")
            for route in routes:
                src_id = route.attrib['src_id'].upper()
                dst_id = route.attrib['dst_id'].upper()
                logger.debug('    route=%s %s', src_id, dst_id)
                self.network_graph.add_edge(
                    src_id, dst_id, route=True, weight=1, length=2
                )

        for connection in connections:
            start_node = connection.attrib['begin'].upper()
            end_node = connection.attrib['end'].upper()
            self.network_graph.add_edge(
                start_node, end_node, route=False, weight=1, length=4
            )
            logger.debug('connection: start=%s, end=%s', start_node, end_node)

        logger.debug('nodes=%s', self.network_graph.nodes)
        logger.debug('edges=%s', self.network_graph.edges)
    
    def _match_service_capability(self, protocol, port):
        """Given a protocol and port, attempt to retrieve known service capabilities
            which utilize them.
        Arguments:
            protocol (string): The protocol detected in the scan data ('TCP' or 'UDP')
            port (int): The port detected in the scan data
        Returns:
            matched_capabilities (list of strings): The names of the matched capabilities.
        """
        # If the port is '0' we can't match it
        if port == '0':
            return []
        matched_capabilities = []
        protocol_port = "{}/{}".format(protocol.lower(), port)
        for capability_name, capability in self.available_capabilities.items():
            if capability.capability_class == 'service':
                for condition in capability.preconditions:
                    if (
                        condition['type'] == 'service'
                        and condition['value'] == protocol_port
                    ):
                        logger.debug(
                            "Matched %s for %s/%s",
                            capability_name,
                            protocol,
                            port,
                        )
                        matched_capabilities.append(capability_name)
                    elif condition['type'] == 'capability':
                        cap_split = '.'.join(capability_name.split('.')[:-1])
                        if cap_split in matched_capabilities:
                            matched_capabilities.append(capability_name)

        return matched_capabilities

    def _add_service_capability(self, host_name, protocol, port):
        """Match capabilities based on detected protocol and port.
            Associate the matched capabilities with the host they
            were detected on.
        Arguments:
            host_name (string): The host the service was detected on
            protocol (string): The protocol the service utilizes
            port (string): The port the service listens on
        Returns:
            (bool): Success (True)
        """
        matched_capabilities = self._match_service_capability(protocol, port)

        if matched_capabilities:
            self._add_capabilities_to_host(host_name, matched_capabilities)
        else:
            protocol_port = "{}/{}".format(protocol.lower(), port)
            if protocol_port in self.unknown_services.keys():
                self.unknown_services[protocol_port].add(host_name)
            else:
                self.unknown_services[protocol_port] = {host_name}

        return True

    def _parse_default(self, host_name, host_ip, host_cpe):
        """This function performs basic tasks required for all scan data types
            such as adding detected host information to the hosts database.
        Arguments:
            host_name (string): The host name (or IP address if no host name was determined)
            host_ip (string): The hosts IP address
            host_cpe (string): Information about the host platform (OS, architecture, etc.)
        """
        logger.debug("Examining results for host: %s", host_name)
        if host_name in self.host_capabilities.keys():
            self.host_capabilities[host_name]['interfaces'].add((host_ip, ''))
            if not self.host_capabilities[host_name]['cpe']:
                self.host_capabilities[host_name]['cpe'] = host_cpe
        else:
            self.host_capabilities[host_name] = {
                'interfaces': {(host_ip, '')},
                'cpe': host_cpe,
                'capabilities': [],
            }

    def _write_common2_csv(self, common_dict_list, input_type):
        """Writes converted common format file to disk
        Arguments:
            common_dict_list (list of dictionaries): Common format scan data
            input_type (string): The original scan data input format
        """
        output_file_path, old_file_name = os.path.split(self.vuln_scan_data_file)
        filename = "{}/{}_{}_{}.common2".format(
            output_file_path, old_file_name.split('.')[0], input_type, 'converted'
        )
        logger.info(
            "Writing converted %s input file to: %s", input_type, filename
        )
        with open(filename, 'w', newline='') as csvfile:
            fieldnames = list(common_dict_list[0].keys())
            writer = csv.DictWriter(
                csvfile, fieldnames=fieldnames, quoting=csv.QUOTE_ALL
            )
            writer.writeheader()
            for item in common_dict_list:
                cves = item['cves']
                if hasattr(cves, "__iter__"):
                    item['cves'] = '/'.join([x.strip() for x in cves])
                writer.writerow(item)

    def _parse_common2_csv(self, input_type):
        """This function simply loads a common format csv file into a
            Python data structure.
        Returns:
            common_dict_list (list of dictionaries): The common format scan data
        """
        if input_type == '':
            filename = self.vuln_scan_data_file
        else:
            output_file_path, old_file_name = os.path.split(self.vuln_scan_data_file)
            filename = "{}/{}_{}_{}.common2".format(
                output_file_path, old_file_name.split('.')[0], input_type, 'converted'
            )
        logger.info(
            "Writing converted %s input file to: %s", input_type, filename
        )
        common_dict_list = []
        with open(filename, 'r', newline='') as csvfile:
            reader = csv.DictReader(csvfile)
            for row in reader:
                common_dict_list.append(dict(row))

        common_out = []
        for item in common_dict_list:
            host_name = item['hostname']
            host_ip = item['hostip']
            host_cpe = item['hostcpe']
            protocol = item['protocol']
            port = item['port']
            item_type = item['type']
            cves = item['cves'].split('/')
            name = item['name']
            module = item['module']
            description = item['description']
            cvss = item['cvss']
            severity = item['severity']
            solution = item['solution']

            if item_type == 'service':
                common_out = self.build_common_service(
                    host_name,
                    host_ip,
                    host_cpe,
                    protocol,
                    port,
                    name,
                    common_out,
                )
            elif item_type == 'exploit':
                # To update metasploit database (metasploit module may be elased from database)
                #if module in self.available_capabilities:
                common_out = self.build_common_exploits(
                        host_name,
                        host_ip,
                        host_cpe,
                        protocol,
                        port,
                        cves,
                        name,
                        module,
                        description,
                        cvss,
                        severity,
                        solution,
                        common_out,
                    )

        return common_out

    def _parse_common_csv(self):
        """This function simply loads a common format csv file into a
            Python data structure.
        Returns:
            common_dict_list (list of dictionaries): The common format scan data
        """
        common_dict_list = []
        with open(self.vuln_scan_data_file, 'r', newline='') as csvfile:
            reader = csv.DictReader(csvfile)
            for row in reader:
                common_dict_list.append(dict(row))

        return common_dict_list

    def _write_common_csv(self, common_dict_list, input_type):
        """Writes converted common format file to disk
        Arguments:
            common_dict_list (list of dictionaries): Common format scan data
            input_type (string): The original scan data input format
        """
        output_file_path, old_file_name = os.path.split(self.vuln_scan_data_file)
        filename = "{}/{}_{}_{}.common".format(
            output_file_path, old_file_name.split('.')[0], input_type, 'converted'
        )
        logger.info(
            "Writing converted %s input file to: %s", input_type, filename
        )
        with open(filename, 'w', newline='') as csvfile:
            fieldnames = list(common_dict_list[0].keys())
            writer = csv.DictWriter(
                csvfile, fieldnames=fieldnames, quoting=csv.QUOTE_ALL
            )
            writer.writeheader()
            for item in common_dict_list:
                writer.writerow(item)

    def _read_common_capabilities(self, common_dict_list):
        """Parses the common format information and adds listed capabilities
            to in memory list of capabilities and associates with hosts.

        Args:
            common_dict_list (list of dictionaries): Common format scan data

        Returns:
            (bool): Success (True) or Failure (False)
        """
        for item in common_dict_list:
            host_name = item['hostname'].upper()
            host_ip = item['hostip']
            host_cpe = item['hostcpe']
            name = item['name']
            solution = item['solution']
            protocol = item['protocol']
            port = item['port']
            item_type = item['type']
            item_class = item['class']
            severity = item['severity']
            cvss = item['cvss']
            rank = item['rank']

            if not host_name:
                host_name = host_ip

            self._parse_default(host_name, host_ip, host_cpe)

            if item_type == 'exploit':
                list_of_name = name.split('/')
                # if name is metasploit module (needed to be modified)
                if list_of_name[0] == 'exploit' or list_of_name[0] == 'auxiliary':
                    module = name 
                    name_mod = self.capabilitydb._get_name_by_module(module, self.available_capabilities)
                    if not name_mod:
                        name_mod = name 
                        module = self.capabilitydb._get_module_by_name(name, self.available_capabilities)
                        
                    if module not in self.available_capabilities.keys():
                        return False 
                    
                    if module not in self.capabilities.keys():
                        capability = self.available_capabilities[module]
                        modified_capability = self._get_capability_from_common_dict(capability, solution, protocol, severity, cvss)
                        self.capabilities[module] = modified_capability
                    self._add_capabilities_to_host(host_name, [module])
                
                # if name is not metasploit module
                else:
                    if name not in self.available_capabilities.keys():
                        return False 
                    if name not in self.capabilities.keys():
                        capability = self.available_capabilities[name]
                        modified_capability = self._get_capability_from_common_dict(capability, solution, protocol, severity, cvss)
                        self.capabilities[name] = modified_capability
                    self._add_capabilities_to_host(host_name, [name])
                    
            elif item_type == 'service':
                if not self._add_service_capability(host_name, protocol, port):
                    return False 
                
        return True 

    def _get_capability_from_common_dict(self, capability, solution, protocol, severity, cvss):
        """obtain capability from common dict

        Args:
            capability (Capability): capability
            solution (str): solution obtained from scan
            protocol (str): protocol obtained from scan
            severity (str): severity obtained from scan
            cvss (str): cvss obtained from scan

        Returns:
            (Capability): modified capability from the scan result
        """
        preconditions = self._preconditions_protocol_from_scan(capability.preconditions, protocol)
        capability_from_dict = Capability(
            capability_id=capability.capability_id,
            title=capability.title,
            capability_class=capability.capability_class,
            subclass=capability.subclass,
            severity=severity,
            cves=capability.cves,
            cvss=cvss,
            preconditions=preconditions,
            actions=capability.actions,
            postconditions=capability.postconditions,
            rank=capability.rank,
            solution=solution
        )
        return capability_from_dict 
    
    def _preconditions_protocol_from_scan(self, preconditions, protocol):
        """modify preconditions from scan results

        Args:
            preconditions (list): the list of preconditions
            protocol (str): protocol obtained from scan result

        Returns:
            (list): the list of modified preconditions
        """
        modify_preconditions = []
        for precon in preconditions:
            if precon['value'] != '':
                if '$protocol' in precon['value']:
                    val_split = precon['value'].split('/')
                    new_precon_val = protocol + '/' + val_split[1]
                    new_precon = {
                        'host': precon['host'],
                        'key': precon['key'],
                        'type': precon['type'],
                        'value': new_precon_val
                    }
                    modify_preconditions.append(new_precon)
                else:
                    modify_preconditions.append(precon)
            else:
                modify_preconditions.append(precon)
        return modify_preconditions

    def build_common_service(
        self,
        host_name,
        host_ip,
        host_cpe,
        protocol,
        port,
        service_name,
        common_out,
    ):
        """Builds common format service capabilities based on information detected in other
            scan data formats.
        Arguments:
            host_name (string): The host name
            host_ip (string): The host's IP address
            host_cpe (string): The host CPE information
            protocol (string): The protocol the service uses
            port (string): The port the service runs on
            service_name (string): The name of the service
            common_out (list of dictionaries): The current list of common formated capabilities
        Returns:
            common_out (list of dictionaries): The list with the new service capabilities added
        """
        matched_capabilities = self._match_service_capability(protocol, port)

        if not matched_capabilities:
            if not self._check_duplicate_common_entry(
                common_out, host_name, protocol=protocol, port=port
            ):
                common_entry = {
                    "hostname": host_name,
                    "hostip": host_ip,
                    "hostcpe": host_cpe,
                    "protocol": protocol,
                    "port": port,
                    "type": "service",
                    "name": service_name,
                    "class": service_name,
                    "rank": CapabilityRank.NORMAL.value,
                    "severity": CapabilitySeverity.NONE.value,
                    "cvss": "",
                    "solution": "Ensure this service is properly secured.",
                }
                common_out.insert(0, common_entry)
        else:
            for capability in matched_capabilities:
                capability = capability.split('.')[0]
                capability_instance = self.capabilities[capability]
                if capability_instance.capability_class == 'service':
                    service_name = capability_instance.title
                    if not self._check_duplicate_common_entry(
                        common_out, host_name, protocol=protocol, port=port
                    ):
                        common_entry = {
                            "hostname": host_name,
                            "hostip": host_ip,
                            "hostcpe": host_cpe,
                            "protocol": protocol,
                            "port": port,
                            "type": "service",
                            "name": service_name,
                            "class": capability_instance.subclass,
                            "rank": capability_instance.rank,
                            "severity": capability_instance.severity,
                            "cvss": capability_instance.cvss,
                            "solution": capability_instance.solution,
                        }
                        logger.debug("Adding common service: %s", common_entry)
                        common_out.insert(0, common_entry)

        return common_out

    def build_common2_service(
        self,
        host_name,
        host_ip,
        host_cpe,
        protocol,
        port,
        service_name,
        common2_out,
    ):
        """Builds common format service capabilities based on information detected in other
            scan data formats.
        Arguments:
            host_name (string): The host name
            host_ip (string): The host's IP address
            host_cpe (string): The host CPE information
            protocol (string): The protocol the service uses
            port (string): The port the service runs on
            service_name (string): The name of the service
            common_out (list of dictionaries): The current list of common formated capabilities
        Returns:
            common_out (list of dictionaries): The list with the new service capabilities added
        """
        matched_capabilities = self._match_service_capability(protocol, port)

        if not matched_capabilities:
            if not self._check_duplicate_common2_entry(
                common2_out, host_name, protocol=protocol, port=port
            ):
                common2_entry = {
                    "hostname": host_name,
                    "hostip": host_ip,
                    "hostcpe": host_cpe,
                    "protocol": protocol,
                    "port": port,
                    "type": "service",
                    "cves": None,
                    "name": service_name,
                    "module": None,
                    "description": None,
                    "severity": CapabilitySeverity.NONE.value,
                    "cvss": "",
                    "solution": "Ensure this service is properly secured.",
                }
            
                common2_out.insert(0, common2_entry)
        else:
            for capability in matched_capabilities:
                capability = capability.split('.')[0]
                capability_instance = self.capabilities[capability]
                if capability_instance.capability_class == 'service':
                    service_name = capability_instance.title
                    if not self._check_duplicate_common2_entry(
                            common2_out, host_name, protocol=protocol, port=port
                    ):
                        common2_entry = {
                            "hostname": host_name,
                            "hostip": host_ip,
                            "hostcpe": host_cpe,
                            "protocol": protocol,
                            "port": port,
                            "type": "service",
                            "cves": None,
                            "name": service_name,
                            "module": None,
                            "description": None,
                            "severity": capability_instance.severity,
                            "cvss": capability_instance.cvss,
                            "solution": capability_instance.solution,
                        }
                        logger.debug("Adding common2 service: %s", common2_entry)
                        common2_out.insert(0, common2_entry)
                    
        return common2_out
   
    def build_common_exploits(
        self,
        host_name,
        host_ip,
        host_cpe,
        protocol,
        port,
        cves,
        metasploit_name_candidate,
        module_candidate,
        description,
        cvss,
        severity,
        solution,
        common_out,
    ):
        """Classifies and builds common format exploit capabilities based on information
            detected in other scan data formats.
        Arguments:
            host_name (string): The host name
            host_ip (string): The host's IP address
            host_cpe (string): The host CPE information
            protocol (string): The protocol the exploitable service uses
            port (string): The port the exploitable service runs on
            cves (List[string]): CVE information list provided in the scan data
            metasploit_name_candidate (string): The metasploit name in the scan data
            module_candidate (string): The metasploit module name in the scan data
            description (string): Description information provided in the scan data
            cvss (string): CVSS information provided in the scan data
            severity (string): Severity information provided in the scan data
            solution (string): Solution information provided in the scan data
            common_out (list of dictionaries): The current list of common formated capabilities
        Returns:
            common_out (list of dictionaries): The list with the new exploit capability added
        """
        #print("===================================")
        #print(" cves       : ", cves)
        for cve in cves:            
            for module in self.capabilitydb._get_modules_by_cve_number(cve, self.capabilitydb.cve_dict):
                common_out = self.build_common_exploit(
                    host_name,
                    host_ip,
                    host_cpe,
                    protocol,
                    port,
                    module,
                    description,
                    cvss,
                    severity,
                    solution,
                    common_out,
                )
                related_names = self.capabilitydb._get_related_names_by_cve(cve, self.available_capabilities, self.capabilitydb.cve_dict)
                for related_name in related_names:
                    related_module = self.capabilitydb._get_module_by_name(related_name, self.available_capabilities)
                    if related_module != '':
                        common_out = self.build_common_exploit(
                            host_name,
                            host_ip,
                            host_cpe,
                            protocol,
                            port,
                            related_module,
                            description,
                            cvss,
                            severity,
                            solution,
                            common_out,
                        )
        
        if metasploit_name_candidate:
            related_modules = self.capabilitydb._get_related_modules_by_name(metasploit_name_candidate, self.available_capabilities, self.capabilitydb.cve_dict)
            for related_module in related_modules:
                if related_module:
                    common_out = self.build_common_exploit(
                        host_name,
                        host_ip,
                        host_cpe,
                        protocol,
                        port,
                        related_module,
                        description,
                        cvss,
                        severity,
                        solution,
                        common_out,
                    )

        if module_candidate:
            if self.capabilitydb._get_name_by_module(module_candidate, self.available_capabilities):
                common_out = self.build_common_exploit(
                    host_name,
                    host_ip,
                    host_cpe,
                    protocol,
                    port,
                    module_candidate,
                    description,
                    cvss,
                    severity,
                    solution,
                    common_out,
                )
                
        return common_out
        
    def build_common_exploit(
        self,
        host_name,
        host_ip,
        host_cpe,
        protocol,
        port,
        metasploit_module,
        description,
        cvss,
        severity,
        solution,
        common_out,
    ):
        if not self._check_duplicate_common_entry(
            common_out, host_name, name=metasploit_module
        ):
            list_of_name = metasploit_module.split('/')
            # to build exploit, auxiliary module is omitted
            if list_of_name[0] != 'auxiliary':
                # if metasploit exploit module 
                if list_of_name[0] == 'exploit':
                    metasploit_info = self.metasploitpap._classify_vulnerability(
                        metasploit_module, description, cvss, port
                    )
                    
                    if not metasploit_info:
                        return common_out
                    exploit_class = metasploit_info['class']
                    rank = metasploit_info['rank'].lower()
                    if exploit_class == 'remote_code_execution':
                        template_capability = self.metasploitpap._get_template_RCE()
                    elif exploit_class == 'privilege_escalation':
                        template_capability = self.metasploitpap._get_template_PE()

                    if not solution:
                        solution = template_capability.solution
                    if metasploit_info:
                        common_entry = {
                            "hostname": host_name,
                            "hostip": host_ip,
                            "hostcpe": host_cpe,
                            "protocol": protocol,
                            "port": port,
                            "type": "exploit",
                            "name": metasploit_module,
                            "class": exploit_class,
                            "rank": rank,
                            "severity": severity,
                            "cvss": cvss,
                            "solution": solution,
                        }
                        common_out.append(common_entry)

                # if name is not metasploit module
                else:
                    exploit_class = self.available_capabilities[list_of_name[0]].capability_class 
                    rank = self.available_capabilities[list_of_name[0]].rank 
                    if not solution:
                        solution = self.available_capabilities[list_of_name[0]].solution 
                    common_entry = {
                        "hostname": host_name,
                        "hostip": host_ip,
                        "hostcpe": host_cpe,
                        "protocol": protocol,
                        "port": port,
                        "type": "exploit",
                        "name": list_of_name[0],
                        "class": exploit_class,
                        "rank": rank,
                        "severity": severity,
                        "cvss": cvss,
                        "solution": solution,
                    }
                    common_out.append(common_entry)     

        return common_out

    def build_common2_exploits(
        self,
        host_name,
        host_ip,
        host_cpe,
        protocol,
        port,
        cves,
        metasploit_name_candidate,
        module_candidate,
        description,
        cvss,
        severity,
        solution,
        common2_out,
    ):
        """Classifies and builds common format exploit capabilities based on information
            detected in other scan data formats.
        Arguments:
            host_name (string): The host name
            host_ip (string): The host's IP address
            host_cpe (string): The host CPE information
            protocol (string): The protocol the exploitable service uses
            port (string): The port the exploitable service runs on
            cves (List[string]): CVE information list provided in the scan data
            metasploit_name_candidate (string): The metasploit name in the scan data
            module_candidate (string): The metasploit module name in the scan data
            description (string): Description information provided in the scan data
            cvss (string): CVSS information provided in the scan data
            severity (string): Severity information provided in the scan data
            solution (string): Solution information provided in the scan data
            common2_out (list of dictionaries): The current list of common2 formated capabilities
        Returns:
            common2_out (list of dictionaries): The list with the new exploit capability added
        """
        common2_entry = {
            "hostname": host_name,
            "hostip": host_ip,
            "hostcpe": host_cpe,
            "protocol": protocol,
            "port": port,
            "type": "exploit",
            "cves": cves,
            "name": metasploit_name_candidate,
            "module": module_candidate,
            "description": description,
            "cvss": cvss,
            "severity": severity,
            "solution": solution,
        }
        common2_out.append(common2_entry)

        return common2_out

    @classmethod
    def _check_duplicate_common_entry(
        cls, common_out, host_name, protocol=None, port=None, name=None
    ):
        """Checks to ensure we don't attempt to add duplicate common format entries for any
            particular host.
        Arguments:
            common_out (list of dictionaries): The current list of common formated capabilities
            host_name (string): The host name
            protocol (string): For services, the protocol used by the service
            port (string): For services, the port the service listens on
            name (string): For exploits, the name of the Metasploit module
        Returns:
            (bool): True indicates a duplicate entry exists.  False indicates no duplicates.
        """
        for item in common_out:
            if item['hostname'] == host_name:
                # This should ensure no duplicate exploits exist
                if name is not None and item['name'] == name:
                    return True
                # This should ensure no duplicate services exist
                if (
                    name is None
                    and item['protocol'] == protocol
                    and item['port'] == port
                ):
                    return True

        return False

    @classmethod
    def _check_duplicate_common2_entry(
        cls, common2_out, host_name, protocol=None, port=None, name=None
    ):
        """Checks to ensure we don't attempt to add duplicate common format entries for any
            particular host.
        Arguments:
            common2_out (list of dictionaries): The current list of common2 formated capabilities
            host_name (string): The host name
            protocol (string): For services, the protocol used by the service
            port (string): For services, the port the service listens on
            name (string): For exploits, the name of the Metasploit module
        Returns:
            (bool): True indicates a duplicate entry exists.  False indicates no duplicates.
        """
        for item in common2_out:
            if item['hostname'] == host_name:
                # This should ensure no duplicate exploits exist
                if name is not None and item['name'] == name:
                    return True
                # This should ensure no duplicate services exist
                if (
                    name is None
                    and item['protocol'] == protocol
                    and item['port'] == port
                ):
                    return True

        return False

    def _parse_convert_nessus(self):
        """Loads, parses and converts Nessus formated scan data to common format
        Returns:
            common_out(list of dictionaries): The converted common formated scan data
        """
        logger.info("Converting nessus input file to common format input file")
        tree = ET.parse(self.vuln_scan_data_file)
        root = tree.getroot()
        common2_out = []

        for report_host in root.findall('./Report/ReportHost'):
            host_name = report_host.attrib['name'].upper()
            host_ip = 'None'
            host_os = host_variation = host_arch = '?'

            for tag in report_host.findall('HostProperties/tag'):
                host_property = tag.attrib['name']
                if host_property == 'host-ip':
                    host_ip = tag.text
                if 'cpe' in host_property:
                    if 'microsoft' in tag.text.lower():
                        host_os = 'W'
                        if 'windows_xp' in tag.text.lower():
                            host_variation = 'XP'
                        elif 'windows_7' in tag.text.lower():
                            host_variation = '7'
                        elif 'windows_vista' in tag.text.lower():
                            host_variation = 'V'
                        elif 'windows_10' in tag.text.lower():
                            host_variation = '10'
                    elif 'linux' in tag.text.lower():
                        host_os = 'L'
                        host_arch = '64'
                        if 'ubuntu' in tag.text.lower():
                            host_variation = 'UB'
                    if 'x86' in tag.text.lower():
                        host_arch = '32'
                    elif 'x64' in tag.text.lower():
                        host_arch = '64'

                elif host_property == 'netbios-name':
                    host_name = tag.text.upper()
                elif host_property == 'hostname' and tag.text != '(none)':
                    host_name = tag.text.upper()

            # If hostname was only in the report as an IP address,
            # attempt to match it with a hostname
            host_name = self.ip_to_hostname(host_name)

            if host_arch == '?':
                for report_item in report_host.findall('ReportItem'):
                    for plugin_output in report_item.findall('plugin_output'):
                        output_text = plugin_output.text.lower()
                        if 'x64' in output_text:
                            host_arch = '64'
                        if 'x86' in output_text and host_arch == '?':
                            host_arch = '32'

            host_cpe = "{}/{}/{}".format(host_os, host_variation, host_arch)
            logger.debug("Host: %s, CPE: %s", host_name, host_cpe)

            for report_item in report_host.findall('ReportItem'):
                protocol = report_item.attrib['protocol'].lower()
                port = report_item.attrib['port']
                name = report_item.attrib['svc_name'].lower()
                try:
                    severity = CapabilitySeverity(
                        _collapse_severity(int(report_item.attrib['severity']))
                    ).name
                except:
                    severity = CapabilitySeverity.HIGH.name
                    
                if port != '0':
                    common2_out = self.build_common2_service(
                        host_name,
                        host_ip,
                        host_cpe,
                        protocol,
                        port,
                        name,
                        common2_out,
                    )

                metasploit_name_element = report_item.find("metasploit_name")
                cves = []
                for cve in report_item.findall("cve"):
                    cves.append(cve.text)

                # Check if this is an exploit with cvs numbers or a metasploit module
                #if metasploit_name_element is not None:
                if len(cves) > 0 or metasploit_name_element is not None:
                    solution_node = report_item.find("solution")
                    if solution_node:
                        solution = solution_node.text
                    else:
                        solution = ''
                    solution = solution.replace('\n', ' ').strip()
                    description = report_item.find("description").text.lower()
                        
                    try:
                        cvss = report_item.find("cvss3_vector").text
                    except:
                        try:
                            cvss = report_item.find("cvss_vector").text
                        except:
                            cvss = ""

                    if metasploit_name_element is not None:
                        metasploit_nessus_name = metasploit_name_element.text
                    else:
                        metasploit_nessus_name = None
                        
                    logger.debug("\tBuilding Common Exploit from nessus scan result: cve=%s, name_candidate=%s", cves, metasploit_nessus_name)
                    common2_out = self.build_common2_exploits(
                        host_name,
                        host_ip,
                        host_cpe,
                        protocol,
                        port,
                        cves,
                        metasploit_nessus_name,
                        None,
                        description,
                        cvss,
                        severity,
                        solution,
                        common2_out,
                    )
                    
        return common2_out

    def parse_convert_nmap_script(self, host_name, host_ip, host_cpe, protocol, portnumber, script, common2_out):
        output = script.attrib['output'].lstrip().lower()
        if output.startswith('vulnerable'):
            description = []
            cve = ""
            module_candidate = None
            for table in script.findall('table'):
                if table.attrib['key'].startswith('CVE-'):
                    cve = table.attrib['key']
                for element in table.findall('elem'):
                    if element.attrib['key'] == 'title':
                        description.append(element.text)
                for inner_table in table.findall('table'):
                    if inner_table.attrib['key'] == 'description':
                        for element in inner_table.findall('elem'):
                            description.append(element.text)
                    if inner_table.attrib['key'] == 'refs':
                        for element in inner_table.findall('elem'):
                            result = re.findall(r'https://github\.com/rapid7/metasploit-framework/blob/master/modules/([0-9A-Za-z/_]+)\.rb', element.text)
                            if result:
                                module_candidate = result[0]
                                module_candidate = module_candidate.replace('exploits/', 'exploit/')
                                    
            if cve and description:
                description = ' '.join(description)
                cvss = ""
                try:
                    risk_factor = re.findall(
                        r'risk factor: (high|critical|medium|low)&#xa;',
                        output,
                    )[0]
                    severity = CapabilitySeverity[
                        risk_factor.upper()
                    ].name
                except:
                    logger.warning(
                        "NMAP Vulnerability %s has no risk rating, assuming 'high'",
                        cve,
                    )
                    severity = CapabilitySeverity.HIGH.name
                    

                #for metasploit_name in related_names:
                logger.debug("\tBuilding Common Exploit from nmap scan result: cve=%s, module_candidate=%s", cve, module_candidate)
                common2_out = self.build_common2_exploits(
                    host_name,
                    host_ip,
                    host_cpe,
                    protocol,
                    portnumber,
                    [cve],
                    None,
                    module_candidate,
                    description,
                    cvss,
                    severity,
                    "",
                    common2_out,
                )

        return common2_out
    
    def _parse_convert_nmap(self):
        """Loads, parses and converts Nmap formated scan data to common format
        Returns:
            common_out(list of dictionaries): The converted common formated scan data
        """
        logger.info("Converting nmap input file to common format input file")
        tree = ET.parse(self.vuln_scan_data_file)
        root = tree.getroot()
        common2_out = []

        for host in root.findall('./host'):
            host_os = host_variation = host_arch = '?'
            host_name = 'None'
            host_ip = host.find('address').attrib['addr']
            for hostname in host.findall('hostnames/hostname'):
                host_name = hostname.attrib['name'].upper()

            try:
                for osclass in host.find('os/osmatch/osclass'):
                    nmap_cpe = osclass.text.lower()
                    if 'microsoft' in nmap_cpe:
                        host_os = 'W'
                        if 'windows_xp' in nmap_cpe:
                            host_variation = 'XP'
                        elif 'windows_7' in nmap_cpe:
                            host_variation = '7'
                        elif 'windows_vista' in nmap_cpe:
                            host_variation = 'V'
                        elif 'windows_10' in nmap_cpe:
                            host_variation = '10'
                    elif 'linux' in nmap_cpe:
                        host_os = 'L'
                        host_arch = '64'
                        if 'ubuntu' in nmap_cpe:
                            host_variation = 'UB'
            except:
                host_os = '?'
                host_arch = '?'
                host_variation = '?'

            host_cpe = "{}/{}/{}".format(host_os, host_variation, host_arch)

            for port in host.findall('ports/port'):
                state = port.find('state').attrib['state']
                if state != 'open':
                    continue
                protocol = port.attrib['protocol'].lower()
                portnumber = port.attrib['portid']
                try:
                    name = port.find('service').attrib['name']
                except:
                    name = ""
                if portnumber != '0':
                    common2_out = self.build_common2_service(
                        host_name,
                        host_ip,
                        host_cpe,
                        protocol,
                        portnumber,
                        name,
                        common2_out,
                    )

                for script in port.findall('script'):
                    common2_out = self.parse_convert_nmap_script(
                        host_name,
                        host_ip,
                        host_cpe,
                        protocol,
                        portnumber,
                        script,
                        common2_out)
                    
            for script in host.findall('hostscript/script'):
                common2_out = self.parse_convert_nmap_script(
                    host_name,
                    host_ip,
                    host_cpe,
                    protocol,
                    portnumber,
                    script,
                    common2_out)

        return common2_out

    def _report_capabilities(self):
        """Simply reports out details regarding each host and the capabilities detected on them"""
        for host, host_info in self.host_capabilities.items():
            host_exploits = []
            host_services = []
            for capability in host_info['capabilities']:
                if self.capabilities[capability].capability_class == 'exploit':
                    host_exploits.append(capability)
                else:
                    host_services.append(capability)
            if len(host_exploits) + len(host_services) > 0:
                logger.info(
                    "Capabilities detected on %s: %d (Exploits: %d, Services: %d)",
                    host,
                    len(host_exploits) + len(host_services),
                    len(host_exploits),
                    len(host_services),
                )
                if host_exploits:
                    logger.debug("\tExploits: %s", ', '.join(host_exploits))
                if host_services:
                    logger.debug("\tServices: %s", ', '.join(host_services))
            elif host != 'ATTACKER':
                logger.warning("Didn't detect ANY capabilities on %s", host)

        if len(self.unknown_services.keys()) > 0:
            logger.debug(
                "Unknown Services: %s", len(self.unknown_services.keys())
            )
            for service, service_info in self.unknown_services.items():
                logger.debug("\t%s on hosts %s", service, service_info)

    @classmethod
    def _fix_metasploit_options(cls, metasploit_options):
        """This function applies various modifications to metasploit options including:
           - inserting placeholders where certain values need to be replaced when
             populating when the capability action is inserted into an attack step (hop)
           - inserting certain hard coded values such as for lport and rport
        Arguments:
           metasploit_options (list of dictionaries): Metasploit options
        Returns:
           actual_options (list): The modified options to be used in the capability action
        """
        actual_options = []
        for option, value in metasploit_options.items():
            if value is not None and value != '':
                actual_options.append('{}={}'.format(option.lower(), value))
            elif option.lower() == 'rhost':
                actual_options.append('rhost=$target_host')
            elif option.lower() == 'lport':
                actual_options.append('lport=4444')
            elif option.lower() == 'rhosts':
                actual_options.append('rhosts=$target_host')
            elif option.lower() == 'httpusername':
                actual_options.append('HttpUsername=$username')
            elif option.lower() == 'username':
                actual_options.append('username=$username')
            elif option.lower() == 'password':
                actual_options.append('password=$password')
            elif option.lower() == 'httppassword':
                actual_options.append('HttpPassword=$password')
            elif option.lower() == 'targeturi':    # This is temporary implementation. Please fix it.
                actual_options.append('targeturi=$uri')
            elif option.lower() == 'session':
                pass
            else:
                logger.warning("Unsupported metasploit option: %s", option)
        actual_options = ' '.join(actual_options)

        return actual_options
