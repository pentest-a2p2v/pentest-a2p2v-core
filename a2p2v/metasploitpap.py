#!/usr/bin/python3
# SPDX-License-Identifier: Apache-2.0
# SPDX-FileCopyrightText: Copyright 2018-2023 Toshiba Corporation and Peraton Labs, Inc.
# See README.md for license details

""" This module is used to classify the vulnerabilities.
"""

import logging 
import re 
from .metasploitdb import MetasploitDB
from .types import Capability

logger = logging.getLogger(__name__)

class MetasploitPAP:
    def __init__(self, only_allowed_modules=True):
        MetasploitDB.load_broken_modules()
        MetasploitDB.load_details(only_allowed_modules)

    def _get_template_RCE(self):
        capability_id_rce = 'remote_code_execution'
        capability_title_rce = 'remote_code_execution'
        capability_class_rce = 'template'
        capability_subclass_rce = ''
        capability_severity_rce = 'high'
        capability_cves_rce = ''
        capability_cvss_rce = ''
        capability_preconditions_rce = [{'host': '$target_host', 'type': 'service', 'key': 'port', 'value': '$protocol/$port'}]
        capability_action_rce = []
        capability_postconditions_rce = [{'type': 'state', 'key': 'current_access', 'value': 'metasploit'}, {'type': 'state', 'key': 'current_host', 'value': '$target_host'}, {'type': 'state', 'key': 'current_role', 'value': 'admin'}]
        capability_rank_rce = ''
        capability_solution_rce = 'Apply product patches.'
        capability_rce = Capability(
            capability_id_rce,
            capability_title_rce,
            capability_class_rce,
            capability_subclass_rce,
            capability_severity_rce,
            capability_cves_rce,
            capability_cvss_rce,
            capability_preconditions_rce,
            capability_action_rce,
            capability_postconditions_rce,
            capability_rank_rce,
            capability_solution_rce
        )
        return capability_rce 
    
    def _get_template_PE(self):
        capability_id_pe = 'privilege_escalation'
        capability_title_pe = 'privilege_escalation'
        capability_class_pe = 'template'
        capability_subclass_pe = ''
        capability_severity_pe = 'high'
        capability_cves_pe = ''
        capability_cvss_pe = ''
        capability_preconditions_pe = [{'host': '$target_host', 'type': 'state', 'key': 'current_access', 'value': 'shell'}]
        capability_action_pe = []
        capability_postconditions_pe = [{'type': 'state', 'key': 'current_role', 'value': 'admin'}]
        capability_rank_pe = ''
        capability_solution_pe = 'Apply product patches.'
        capability_pe = Capability(
            capability_id_pe,
            capability_title_pe,
            capability_class_pe,
            capability_subclass_pe,
            capability_severity_pe,
            capability_cves_pe,
            capability_cvss_pe,
            capability_preconditions_pe,
            capability_action_pe,
            capability_postconditions_pe,
            capability_rank_pe,
            capability_solution_pe
        )
        return capability_pe 

    @classmethod
    def _classify_vulnerability(cls, module, description, cvss, port):
        """Attempts to classify a detected vulnerability as either remote code execution (RCE) or
           privilege escalation (PE)
        Arguments:
           module (string): Metasploit module
           description (string): Vulnerability description from scan data
           cvss (string): CVSS information from scan data
           port (int): The port the vulnerability was detected on
        Returns:
           (dict) or (None): Information regarding the vulnerability's rank,
            targets and it's classification if it could be classified
        """
        rce_desc_match_strings = [
            r'.*(command|code) execution.*',
            r'.*arbitrary (code|command).*',
        ]
        rce_desc_nomatch_strings = [r'.*(implant|click).*', r'.*trick user.*']
        rce_cvss_match_regex = r'.*'
        rce_cvss_nomatch_regex = r'.*(UI:R|AV:L)/.*'

        pe_desc_match_strings = [
            '.*(elevation|escalation) of privilege.*',
            'privilege escalation',
        ]
        pe_desc_nomatch_strings = []
        pe_cvss_match_regex = r'.*AV:L/.*'
        pe_cvss_nomatch_regex = r'.*/UI:R/.*'

        metasploit_module_undesirables = '.*_check|auxiliary/dos.*'

        #module = MetasploitDB.get_module_by_name(name)

        # Disregard modules which match the regex.  No check only modules and no denial of service.
        if re.match(metasploit_module_undesirables, module):
            return None

        metasploit_info = MetasploitDB.get_info_by_module(module)
        
        if metasploit_info:
            metasploit_options = MetasploitDB.get_options_by_module(module)
            parse_this = "{} {}".format(
                description.lower(), metasploit_info.description.lower()
            ).replace('\n', '')

            rce_match = False
            pe_match = False
            #if (
            #    metasploit_info.module_type == 'exploit'
            #    and (
            #        'RHOSTS' in metasploit_options.keys()
            #        or 'RHOST' in metasploit_options.keys()
            #    )
            #    and 'cmd' not in metasploit_info.arch
            #):
            if (('RHOSTS' in metasploit_options.keys()
                 or 'RHOST' in metasploit_options.keys())
                and 'RPORT' in metasploit_options.keys()
                ):
                if ('SESSION' not in metasploit_options.keys()):
                    #for rce_match_string in rce_desc_match_strings:
                    #    if (
                    #        re.match(rce_match_string, parse_this, re.IGNORECASE)
                    #        and re.match(rce_cvss_match_regex, cvss)
                    #        and not re.match(rce_cvss_nomatch_regex, cvss)
                    #    ):
                    cvss_decomposed = cvss.split('/')
                    rce_match = all(s not in cvss_decomposed for s in ['I:N', 'A:N', 'C:N'])
                    #for rce_nomatch_string in rce_desc_nomatch_strings:
                    #    if re.match(
                    #        rce_nomatch_string, parse_this, re.IGNORECASE
                    #    ):
                    #        rce_match = False
                    #print(" [RCE]",module,":",metasploit_info.module_type, ":", metasploit_options)
                    if rce_match:
                        if not port or port != '0' or port == '0':
                            logger.debug(
                                "Classified '%s' as Remote Code Execution(type:%s, options:%s)",
                                module, metasploit_info.module_type, metasploit_options
                            )
                            return {
                                'rank': metasploit_info.rank,
                                'targets': metasploit_info.targets,
                                'class': 'remote_code_execution',
                            }
                else:
                    logger.debug("UNKNOWN Type: '%s' (type:%s, options: %s)",
                                 module, metasploit_info.module_type, metasploit_options)
            elif('RHOSTS' not in metasploit_options.keys()
                 and 'RHOST' not in metasploit_options.keys()
                 and 'RPORT' not in metasploit_options.keys()
                 ):
                if ('SESSION' in metasploit_options.keys()):
                    #for pe_match_string in pe_desc_match_strings:
                    #    if (
                    #        re.match(pe_match_string, parse_this, re.IGNORECASE)
                    #        and re.match(pe_cvss_match_regex, cvss)
                    #        and not re.match(pe_cvss_nomatch_regex, cvss)
                    #    ):
                    pe_match = True
                    #for pe_nomatch_string in pe_desc_nomatch_strings:
                    #    if re.match(
                    #        pe_nomatch_string, parse_this, re.IGNORECASE
                    #    ):
                    #        pe_match = False
                    #print(" [PE]",module,":", metasploit_info.module_type,":",metasploit_options)
                    if pe_match:
                        logger.debug(
                            "Classified '%s' as Privilege Escalation(type:%s, options:%s)",
                            module, metasploit_info.module_type, metasploit_options
                        )
                        return {
                            'rank': metasploit_info.rank,
                            'targets': metasploit_info.targets,
                            'class': 'privilege_escalation',
                        }
                else:
                    #print(" [UNKNOWN]",module,":", metasploit_info.module_type,":",metasploit_options)
                    logger.debug("UNKNOWN Type: '%s' (type:%s, options: %s)",
                                 module, metasploit_info.module_type, metasploit_options)
            else:
                #print(" [UNKNOWN]",module,":",metasploit_info.module_type,":",metasploit_options)
                logger.debug("UNKNOWN Type: '%s' (type:%s, options: %s)", module, metasploit_info.module_type, metasploit_options)
                
        return None

