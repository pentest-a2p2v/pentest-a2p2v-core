#!/usr/bin/env python3
#
#  Copyright (C) 2018-2021 Toshiba Corporation and Perspecta Labs, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

""" Metasploit RPC module
"""
import argparse
import json
import logging
from typing import Dict, List, Set, Union

import msgpack
import requests

from .common import create_default_metasploit_config
from .config import config

logger = logging.getLogger(__name__)

DEFAULT_OPTIONS = {
    "exploit/multi/elasticsearch/script_mvel_rce": {
        "HttpUsername": "sploit",
        "HttpPassword": "sploit",
        "TARGETURI": "/",
    },
    "exploit/multi/http/axis2_deployer": {
        "HttpUsername": "sploit",
        "HttpPassword": "sploit",
    },
    "exploit/multi/http/struts_dmi_rest_exec": {
        "HttpUsername": "sploit",
        "HttpPassword": "sploit",
        "TARGETURI": "/",
    },
    "exploit/multi/http/tomcat_mgr_upload": {
        "RHOST": "$target_host",
        "RPORT": 8282,
        "HttpUsername": "sploit",
        "HttpPassword": "sploit",
        "TARGETURI": "/",
    },
    "exploit/multi/http/wp_ninja_forms_unauthenticated_file_upload": {
        "RHOST": "$target_host",
        "HttpUsername": "sploit",
        "HttpPassword": "sploit",
        "TARGETURI": "/wordpress/",
        "FORM_PATH": "/index.php/king-of-hearts/",
    },
    "exploit/multi/misc/java_jmx_server": {},
    "exploit/multi/misc/weblogic_deserialize_asyncresponseservice": {
        "HttpUsername": "sploit",
        "HttpPassword": "sploit",
        "TARGETURI": "/",
    },
    "exploit/windows/iis/iis_webdav_scstoragepathfromurl": {
        "HttpUsername": "sploit",
        "HttpPassword": "sploit",
        "TARGETURI": "/",
    },
    "exploit/windows/rdp/cve_2019_0708_bluekeep_rce": {},
    "exploit/windows/smb/ms17_010_psexec": {},
    "exploit/windows/smb/ms17_010_eternalblue": {},
    "exploit/windows/smb/ms10_061_spoolss": {},
}

ALLOWED_MODULES = [
    "exploit/multi/elasticsearch/script_mvel_rce",
    "exploit/multi/http/axis2_deployer",
    "exploit/multi/http/struts_dmi_rest_exec",
    "exploit/multi/http/tomcat_mgr_upload",
    "exploit/multi/http/wp_ninja_forms_unauthenticated_file_upload",
    "exploit/multi/misc/java_jmx_server",
    "exploit/multi/misc/weblogic_deserialize_asyncresponseservice",
    "exploit/unix/ftp/vsftpd_234_backdoor",
    "exploit/unix/irc/unreal_ircd_3281_backdoor",
    "exploit/unix/misc/distcc_exec",
    "exploit/windows/iis/iis_webdav_scstoragepathfromurl",
    "exploit/windows/rdp/cve_2019_0708_bluekeep_rce",
    "exploit/windows/smb/ms17_010_eternalblue",
    "exploit/windows/smb/ms17_010_psexec",
    "exploit/windows/smb/ms10_061_spoolss",
]

ALLOWED_FIELDS = set(['type', 'name', 'fullname', 'rank', 'description'])

ALLOWED_OPTIONS = set(
    [
        "RHOST",
        "RHOSTS",
        "LPORT",
        "TARGETURI",
        "FORM_PATH",
        "RPORT",
        "HttpUsername",
        "HttpPassword",
    ]
)


def decode(data: Union[str, bytes]) -> str:
    """Decode a byte string, if provided
    Arguments:
        data (str or bytes): input value
    Returns:
        str: data decoded as a string
    """
    if isinstance(data, bytes):
        return data.decode("utf-8")
    if isinstance(data, dict):
        return {decode(name): decode(value) for name, value in data.items()}
    if isinstance(data, list):
        return [decode(item) for item in data]
    return data


def packb(data) -> bytes:
    """Call the msgpack.packb function"""
    return msgpack.packb(data)


def unpackb(data: bytes):
    """Call the msgpack.unpackb function"""
    return msgpack.unpackb(data, strict_map_key=False)


# Variables
class MsfRpcClient:
    """This class is used to interact with the Metasploit RPC API.
    To use it, the Metasploit RPC daemon must be first running.
    It can be started using the command msfrpcd command.
    e.g. msfrpcd -P welcome1 -S -U msf -a 127.0.0.1 -f -p 55552
    """

    def __init__(self):
        """Obtain the MSF API parameters from the configuration."""
        # Parameters are stored in config
        host = config.get('METASPLOIT', 'host', fallback='127.0.0.1')
        port = config.getint('METASPLOIT', 'port', fallback=55552)
        uri = config.get('METASPLOIT', 'uri', fallback="/api/")

        self.username = config.get('METASPLOIT', 'user', fallback='msf')
        self.password = config.get(
            'METASPLOIT', 'password', fallback='welcome1'
        )
        self.ssl = config.getboolean('METASPLOIT', 'ssl', fallback=False)
        self.session = requests.Session()
        self.session.trust_env = config.getboolean(
            'METASPLOIT', 'use_system_proxy', fallback=False
        )
        self.token = None
        self.headers = {"Content-type": "binary/message-pack"}
        if self.ssl:
            self.url = f"https://{host}:{port}{uri}"
        else:
            self.url = f"http://{host}:{port}{uri}"

    def login(self):
        """Login to the MSF API and store the token"""
        if self.token is None:
            logger.info("Logging in to MSF API at %s", self.url)
            result = self.session.post(
                self.url,
                data=msgpack.packb(
                    ["auth.login", self.username, self.password]
                ),
                headers=self.headers,
                verify=False,
            )
            if result.status_code != 200:
                raise requests.exceptions.ConnectionError(
                    f"Login to {self.url} failed with {result.status_code}",
                    response=result
                )
            response = unpackb(result.content)
            self.token = response.get(b"token", "").decode("utf-8")
            logger.debug("Response: %s", response)

    def is_connected(self) -> bool:
        """Return True if authenticated to the Metasploit RPC API"""
        return self.token is not None

    def send_cmd(self, *args) -> Dict:
        """Run a Metasploit API command and return the result"""
        decoded_result = None

        # If not already logged in, attempt to login
        if self.token is None:
            self.login()

        if self.token is not None:
            try:
                # Add the authentication token
                data = list(args)
                data.insert(1, self.token)

                # Pack the message
                packed_data = packb(data)
                result = self.session.post(
                    self.url,
                    data=packed_data,
                    headers=self.headers,
                    verify=False,
                )

                decoded_result = result.content

                if isinstance(decoded_result, bytes):
                    unpacked_result = unpackb(result.content)
                    decoded_result = decode(unpacked_result)
            except ValueError as exception:
                logger.exception(exception)
                logger.error("Result: %s, %s", result, result.content)
        logger.debug('send_cmd(%s): result=%s', args, decoded_result)
        return decoded_result

    def logout(self):
        """Logout of the MSF API and invalidate the token"""
        if self.token is not None:
            logger.info("Logging out of MSI API")
            result = self.session.post(
                self.url,
                data=packb(["auth.logout", self.token]),
                headers=self.headers,
                verify=False,
            )
            self.token = False
            logger.info("Logged out: %s", result)

    def search(self, module_filter: str = "") -> List[Dict[str, str]]:
        """Use the module.search API command to look for modules
        Arguments:
            module_filter(str): filter to pass to module.search
        Returns:
            modules: list of modules with type, name, fullname, rank and
                     disclosuredate
        """
        logger.info('Calling module.search %s', module_filter)
        result = self.session.post(
            self.url,
            data=packb(["module.search", self.token, module_filter]),
            headers=self.headers,
            verify=False,
        )
        modules = unpackb(result.content)
        return modules

    def info(self, fullname: str) -> Dict:
        """Use the module.info API command to get module details
        Arguments:
            fullname(str): module name
        Returns:
            dict: details about the module including options
        """
        logger.debug("Calling module.info: fullname = %s", fullname)
        result = self.session.post(
            self.url,
            data=packb(["module.info", self.token, "", fullname]),
            headers=self.headers,
            verify=False,
        )
        try:
            info = unpackb(result.content)
        except ValueError as error:
            info = result.content
            logger.error(error)

        return info

    def create_console(self):
        """Return an instance of a Metasploit console"""
        return MsfConsole(self)

    def _stop_session(self, session_id: str):
        logger.info("Stopping session %s", session_id)
        self.send_cmd('session.stop', session_id)

    def stop_all_sessions(self):
        """Stop all sessions"""
        if self.token is not None:
            sessions = self.send_cmd('session.list')
            if isinstance(sessions, dict):
                for session_id in sessions.keys():
                    self._stop_session(session_id)


class MsfConfig:
    """Create the Metasploit configuration file by querying MSF RPC API"""

    def __init__(self):
        self.rpc = MsfRpcClient()

    def create_metasploit_config(
        self, details_db_filename: str, only_allowed_modules: bool = True
    ):
        """Create the metasploit configuration file by querying MSF RPC API.
           If there are any issues connecting to the API, use the default.

        Arguments:
            details_db_filename(str): name of the output file
            only_allowed_modules(bool): if True, limit to a subset of modules
        """
        try:
            self._create_metasploit_config_from_api(
                details_db_filename, only_allowed_modules
            )
        except requests.exceptions.ConnectionError as error:
            logger.error(error)
            logger.error(
                'Could not connect to Metasploit API - '
                'Using default Metasploit configuration'
            )
            print(
                "Could not connect to Metasploit API - "
                "Using default Metasploit configuration."
            )
            create_default_metasploit_config()

    def _create_metasploit_config_from_api(
        self, details_db_filename: str, only_allowed_modules: bool = True
    ):
        """Create the metasploit configuration file by querying MSF RPC API.
           Get list of module names, query and parse module information,
           store the results to a JSON formatted file.

        Arguments:
            details_db_filename(str): name of the output file
            only_allowed_modules(bool): if True, limit to a subset of modules
        """
        output = {}
        self.rpc.login()

        # Get the appropriate set of module names
        if only_allowed_modules:
            logger.info(
                'Loading only allowed modules.  To load all, run with --reload'
            )
            module_names = ALLOWED_MODULES
        else:
            logger.info(
                'Loading ALL Metasploit modules, may take a few minutes'
            )
            module_names = self.get_all_modules()

        # Parse the information from all the modules
        for module_name in module_names:
            info = self.parse_info(module_name)
            output[module_name] = info

        # Write to file
        with open(details_db_filename, 'w') as out_fp:
            json.dump(obj=output, fp=out_fp, indent=4)
        self.rpc.logout()

    @classmethod
    def parse_cves(cls, references: List[List]) -> List[str]:
        """Given the references in the Metasploit module information,
           parse out a list of CVE numbers:
        Arguments:
            list: list of references from MSF module info
        Returns:
            list: cve numbers
        """
        cve_list = []
        for reference in references:
            try:
                reference_type, reference_id = reference
                reference_type = decode(reference_type)
                reference_id = decode(reference_id)

                if reference_type == 'CVE':
                    cve_list.append(reference_id)
            except AttributeError as error:
                logger.error(error)
            except ValueError as error:
                logger.error(error)

        return cve_list

    def parse_info(self, fullname: str) -> Dict:
        """Retrieve module information, parse it and return a simplified dataset:
           - Limit items to fields in ALLOWED_FIELDS
           - Place CVE references in a new list indexed by "cves"
           - Format options into a list of name, value pairs where
             - name is the option
             - value is the default value

        Arguments:
            fullname (str): module name
        Returns:
            dict: parsed information
        """
        json_result = {}
        info = self.rpc.info(fullname)

        # Get top level fields
        for name, value in info.items():
            name = decode(name)
            if name in ALLOWED_FIELDS and isinstance(value, bytes):
                value = value.decode("utf-8")
                json_result[name] = value

        # Architectures
        arch_list = []
        for arch in info.get(b'arch', []):
            arch = decode(arch)
            arch_list.append(arch)

        json_result['arch'] = arch_list

        # Targets
        targets = decode(info.get(b'targets', {}))
        json_result['targets'] = targets

        # Only obtain CVEs from the references
        json_result['cves'] = self.parse_cves(info.get(b'references', []))

        # Only get the options we are interested in
        options = {}
        default_options = DEFAULT_OPTIONS.get(fullname, {})

        for option_name, option_values in info.get(b"options", {}).items():
            option_name = decode(option_name)

            if option_name in ALLOWED_OPTIONS:
                option_value = decode(option_values.get(b"default", ""))
                option_value = default_options.get(option_name, option_value)
                options[option_name] = option_value

        json_result["options"] = options

        return json_result

    @classmethod
    def get_broken_modules(cls) -> Set[str]:
        """Get names of broken modules and avoid querying them."""
        broken_modules = set()
        broken = (
            config.get('METASPLOIT', 'broken_modules', fallback='')
            .replace('"', '')
            .replace("'", "")
        )

        for broken_module in broken.split(' '):
            logger.info('Broken module %s', broken_module)
            broken_modules.add(broken_module)

        return broken_modules

    def get_all_modules(self) -> List[str]:
        """Get a list of all module names, skipping broken modules
        Returns:
            list: metasploit module names (fullname)
        """
        module_names = []
        broken_modules = self.get_broken_modules()
        logger.info('Querying module information')
        modules = self.rpc.search("")

        for module in modules:
            module_name = decode(module.get(b"fullname", ""))
            if module_name in broken_modules:
                logger.info('Skipping broken module %s', module_name)
            else:
                module_names.append(module_name)

        return module_names


class MsfConsole:
    """Class to interact with the Metasploit console"""

    def __init__(self, rpc):
        """Create a Metasploit console and store the console id"""
        self._rpc = rpc
        self._console_id = None
        response = self._rpc.send_cmd('console.create')
        if isinstance(response, dict):
            self._console_id = response.get('id', None)
            logger.info('Obtained console id: %s', self._console_id)
            self.prompt = 'msf5> '

    def write_and_read(self, msg: str, echo: bool = True) -> Dict:
        """Write to the console and read the response"""
        self.write(msg, echo)
        return self.read(echo)

    def write(self, msg: str, echo: bool = True):
        """Write to the Metasploit console"""
        if self._console_id is None:
            logger.error("Not connected to Metasploit API")
            return None

        # Append the newline character if not present
        if msg[-1] != '\n':
            msg = f'{msg}\n'

        logger.debug('Sending message: %s', msg)
        if echo and msg.strip():
            print(f'{self.prompt}{msg.strip()}')
        return self._rpc.send_cmd('console.write', self._console_id, msg)

    @classmethod
    def parse_prompt(cls, message: Dict):
        """Get the prompt from the Metasploit console response"""
        if not isinstance(message, dict):
            return 'msf5>'
        return message.get('prompt', 'default')

    def read(self, echo: bool = True) -> Dict:
        """Read from the Metasploit console"""
        if self._console_id is None:
            logger.error("Not connected to Metasploit API")
            return None

        response = self._rpc.send_cmd('console.read', self._console_id)
        self.prompt = self.parse_prompt(response)
        if echo:
            self.print_result(response)
        logger.debug('Read response: %s', response)
        return response

    @classmethod
    def print_result(cls, response):
        """Given a response from the Metasploit RPC to a console
        command, output the result"""
        if isinstance(response, dict):
            data = response.get('data', '')
            if data:
                print(data)

    def destroy(self):
        """Close the console"""
        if self._console_id is None:
            logger.error("Not connected to Metasploit API")
            return
        logger.info('Closing console %s', self._console_id)
        self._rpc.send_cmd('console.destroy', self._console_id)


def parse_args():
    """Parse command line arguments"""
    parser = argparse.ArgumentParser(prog='Metasploit RPC Library')
    parser.add_argument('command', choices=['config', 'command', 'console'])
    return parser.parse_args()


def create_metasploit_config(filename='metasploit_config.json'):
    """Connect to the RPC Client and create the metasploit configuration"""
    msf_config = MsfConfig()
    msf_config.create_metasploit_config(filename)


def send_raw_commands():
    """Allow the user to send raw commands to Metasploit RPC"""
    print('Send raw commands (enter to stop)')
    client = MsfRpcClient()
    client.login()
    try:
        user_input = input('> ')
        while user_input:
            commands = user_input.split(' ')
            print(client.send_cmd(*commands))
            user_input = input('> ')
    except EOFError:
        pass
    client.logout()


def send_console_commands():
    """Allow the user to send commands to the console via Metasploit RPC"""
    print('Connecting to Metasploit API')
    client = MsfRpcClient()
    client.login()
    console = client.create_console()
    _ = console.read()

    try:
        user_input = input(f'{console.prompt}')
        while user_input:
            console.write(user_input, echo=False)
            console.read(user_input)
            user_input = input(f'{console.prompt}')
    except EOFError:
        pass

    console.destroy()
    client.logout()


def main():
    """Create a metasploit configuration file in the current directory."""
    logger.setLevel('DEBUG')
    stream_handler = logging.StreamHandler()
    stream_handler.setLevel('DEBUG')

    # create formatter
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    stream_handler.setFormatter(formatter)
    logger.addHandler(stream_handler)

    args = parse_args()
    if args.command == 'cache':
        create_metasploit_config()
    elif args.command == 'command':
        send_raw_commands()
    elif args.command == 'console':
        logger.setLevel('WARN')
        send_console_commands()


if __name__ == "__main__":
    main()
